grammar PrimGrammar;

datei returns
[java.util.List<de.hechler.patrick.codesprachen.primitive.compile.objects.commands.Command> cmds]
:
	{$cmds = new java.util.ArrayList<>();}

	(
		command
		{$cmds.add($command.cmd);}

	)+ EOF
;

command returns
[de.hechler.patrick.codesprachen.primitive.compile.objects.commands.Command cmd]
:
	(
		mov
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.mov, $mov.p1, $mov.p2);}

	)
	|
	(
		add
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.add, $add.p1, $add.p2);}

	)
	|
	(
		sub
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.sub, $sub.p1, $sub.p2);}

	)
	|
	(
		mul
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.mul, $mul.p1, $mul.p2);}

	)
	|
	(
		div
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegRegCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.div, $div.p1, $div.p2);}

	)
	|
	(
		neg
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.neg, $neg.num);}

	)
	|
	(
		and
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.and, $and.p1, $and.p2);}

	)
	|
	(
		or
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.or, $or.p1, $or.p2);}

	)
	|
	(
		xor
	)
	{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.xor, $xor.p1, $xor.p2);}

	|
	(
		not
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.not, $not.num);}

	)
	|
	(
		cmp
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.NumNumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.cmp, $cmp.p1, $cmp.p2);}

	)
	|
	(
		jmp
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.jmp, $jmp.lname);}

	)
	|
	(
		jmpeq
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.jmpeq, $jmpeq.lname);}

	)
	|
	(
		jmpne
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.jmpne, $jmpne.lname);}

	)
	|
	(
		jmpgt
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.jmpgt, $jmpgt.lname);}

	)
	|
	(
		jmpge
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.jmpge, $jmpge.lname);}

	)
	|
	(
		jmplo
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.jmplo, $jmplo.lname);}

	)
	|
	(
		jmple
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.jmple, $jmple.lname);}

	)
	|
	(
		push
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.NumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.push, $push.num);}

	)
	|
	(
		pop
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.RegCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.pop, $pop.num);}

	)
	|
	(
		call
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.call, $call.lname);}

	)
	|
	(
		calleq
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.calleq, $calleq.lname);}

	)
	|
	(
		callne
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.callne, $callne.lname);}

	)
	|
	(
		callgt
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.callgt, $callgt.lname);}

	)
	|
	(
		callge
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.callge, $callge.lname);}

	)
	|
	(
		calllo
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.calllo, $calllo.lname);}

	)
	|
	(
		callle
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.callle, $callle.lname);}
		/*
		 * TODO:
	sjmp(0x11, 8, 0), sjmpeq(0x12, 8, 0), sjmpne(0x13, 8, 0), sjmpgt(0x14, 8, 0), sjmpge(0x15, 8, 0), sjmplo(0x16, 8, 0), sjmple(0x17, 8, 0),
	
	scall(0x22, 8, 0), scalleq(0x23, 8, 0), scallne(0x24, 8, 0), scallgt(0x25, 8, 0), scallge(0x26, 8, 0), scalllo(0x27, 8, 0), scallle(0x28, 8, 0),
		 
		 */
	)
	|
	(
		ret
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.Command.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.ret);}

	)
	|
	(
		exit
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.NumCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.exit, $exit.num);}
		/*
		 * TODO:
	getInstPointer(0x40, 8, 1), getStackPointer(0x41, 8, 1), getStackOverflowPoint(0x42, 8, 1),
	
	setInstPointer(0x43, 8, 1), setStackPointer(0x44, 8, 1), setStackOverflowPoint(0x45, 8, 1),
		 
		 */
	)
	|
	(
		label
		{$cmd = de.hechler.patrick.codesprachen.primitive.compile.objects.commands.StrCommand.create(de.hechler.patrick.codesprachen.primitive.compile.enums.Commands.label, $label.labelName);}

	)
;

mov returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	MOV
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

add returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	ADD
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

sub returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	SUB
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

mul returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	MUL
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

div returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	DIV
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

neg returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num num]
:
	NEG nummer [1]
	{$num = $nummer.num;}

;

and returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	AND
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

or returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	OR
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

xor returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	XOR
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

not returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num num]
:
	NOT nummer [1]
	{$num = $nummer.num;}

;

cmp returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num p1,
de.hechler.patrick.codesprachen.primitive.compile.objects.Num p2]
:
	CMP
	(
		nummer [1]
		{$p1 = $nummer.num;}

	) PARAM_SEPARATOR
	(
		nummer [0]
		{$p2 = $nummer.num;}

	)
;

jmp returns [String lname]
:
	JMP NAME
	{$lname = $NAME.getText();}

;

jmpeq returns [String lname]
:
	JMPEQ NAME
	{$lname = $NAME.getText();}

;

jmpne returns [String lname]
:
	JMPNE NAME
	{$lname = $NAME.getText();}

;

jmpgt returns [String lname]
:
	JMPGT NAME
	{$lname = $NAME.getText();}

;

jmpge returns [String lname]
:
	JMPGE NAME
	{$lname = $NAME.getText();}

;

jmplo returns [String lname]
:
	JMPLO NAME
	{$lname = $NAME.getText();}

;

jmple returns [String lname]
:
	JMPLE NAME
	{$lname = $NAME.getText();}

;

push returns
[de.hechler.patrick.codesprachen.primitive.compile.objects.Num num]
:
	PUSH nummer [0]
	{$num = $nummer.num;}

;

pop returns [de.hechler.patrick.codesprachen.primitive.compile.objects.Num num]
:
	POP nummer [0]
	{$num = $nummer.num;}

;

call returns [String lname]
:
	CALL NAME
	{$lname = $NAME.getText();}

;

calleq returns [String lname]
:
	CALLEQ NAME
	{$lname = $NAME.getText();}

;

callne returns [String lname]
:
	CALLNE NAME
	{$lname = $NAME.getText();}

;

callgt returns [String lname]
:
	CALLGT NAME
	{$lname = $NAME.getText();}

;

callge returns [String lname]
:
	CALLGE NAME
	{$lname = $NAME.getText();}

;

calllo returns [String lname]
:
	CALLLO NAME
	{$lname = $NAME.getText();}

;

callle returns [String lname]
:
	CALLLE NAME
	{$lname = $NAME.getText();}

;

ret
:
	RET
;

exit returns
[de.hechler.patrick.codesprachen.primitive.compile.objects.Num num]
:
	EXIT nummer [0]
	{$num = $nummer.num;}

;

label returns [String labelName]
:
	LABEL_START NAME
	{$labelName = $NAME.getText();}

;

nummer [long minDeep] returns
[de.hechler.patrick.codesprachen.primitive.compile.objects.Num num]
:
	(
		simpleNum
		{$num = $simpleNum.num;}

	)
	|
	(
		REG_START
		(
			subnum = nummer [-1]
			{boolean hadSN = false;}

			(
				simpleNum
				{
				hadSN = true;
					
					if ($simpleNum.num.isNum(0)) {
						$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createRegNumoff($subnum.num, $simpleNum.num.num(0));
					} else {
						switch($simpleNum.num.sr(0)) {
							case 0:
								$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createRegAXOff($subnum.num);
							case 1:
								$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createRegBXOff($subnum.num);
							case 2:
								$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createRegCXOff($subnum.num);
							case 3:
								$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createRegDXOff($subnum.num);
							default:
								throw new RuntimeException("illegal special register: " + $simpleNum.num.sr(0));
						}
					}
				}

			)?
			{
				if (!hadSN) {
					$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createRegNumoff($subnum.num, 0l);
				}
			}

		) REG_END
	)
	{
		if ($num.deep() < minDeep) {
			throw new RuntimeException("minDeep=" + minDeep + " deep=" + $num.deep());
		}
	}

;

simpleNum returns
[de.hechler.patrick.codesprachen.primitive.compile.objects.Num num]
:
	(
		HEX_SYMBOL hexnum
		{$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createConstNum($hexnum.val);}

	)
	|
	(
		DEC_SYMBOL decnum
		{$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createConstNum($decnum.val);}

	)
	|
	(
		BIN_SYMBOL binnum
		{$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createConstNum($binnum.val);}

	)
	|
	(
		AX_NUM
		{$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createConstAX();}

	)
	|
	(
		BX_NUM
		{$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createConstBX();}

	)
	|
	(
		CX_NUM
		{$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createConstCX();}

	)
	|
	(
		DX_NUM
		{$num = de.hechler.patrick.codesprachen.primitive.compile.objects.Num.createConstDX();}

	)
;

hexnum returns [long val]
:
	(
		HEX_NUM
		{$val = Long.parseLong($HEX_NUM.getText(), 16);}

	)
	|
	(
		DEC_NUM
		{$val = Long.parseLong($DEC_NUM.getText(), 16);}

	)
	|
	(
		BIN_NUM
		{$val = Long.parseLong($BIN_NUM.getText(), 16);}

	)
;

decnum returns [long val]
:
	(
		DEC_NUM
		{$val = Long.parseLong($DEC_NUM.getText(), 10);}

	)
	|
	(
		BIN_NUM
		{$val = Long.parseLong($BIN_NUM.getText(), 10);}

	)
;

binnum returns [long val]
:
	BIN_NUM
	{$val = Long.parseLong($BIN_NUM.getText(), 2);}

;

EXIT
:
	'EXIT'
;

RET
:
	'RET'
;

CALLLE
:
	'CALLLE'
;

CALLLO
:
	'CALLLO'
;

CALLGE
:
	'CALLGE'
;

CALLGT
:
	'CALLGT'
;

CALLNE
:
	'CALLNE'
;

CALLEQ
:
	'CALLEQ'
;

CALL
:
	'CALL'
;

POP
:
	'POP'
;

PUSH
:
	'PUSH'
;

JMPLE
:
	'JMPLE'
;

JMPLO
:
	'JMPLO'
;

JMPGE
:
	'JMPGE'
;

JMPGT
:
	'JMPGT'
;

JMPNE
:
	'JMPNE'
;

JMPEQ
:
	'JMPEQ'
;

JMP
:
	'JMP'
;

CMP
:
	'CMP'
;

NOT
:
	'NOT'
;

XOR
:
	'XOR'
;

OR
:
	'OR'
;

AND
:
	'AND'
;

NEG
:
	'NEG'
;

DIV
:
	'DIV'
;

MUL
:
	'MUL'
;

SUB
:
	'SUB'
;

ADD
:
	'ADD'
;

MOV
:
	'MOV'
;

PARAM_SEPARATOR
:
	','
;

LABEL_START
:
	'#'
;

HEX_SYMBOL
:
	'HEX'
;

DEC_SYMBOL
:
	'DEC'
;

BIN_SYMBOL
:
	'BIN'
;

BIN_NUM
:
	[01]+
;

DEC_NUM
:
	[0-9]+
;

HEX_NUM
:
	[0-9a-fA-F]+
;

AX_NUM
:
	'AX'
;

BX_NUM
:
	'BX'
;

CX_NUM
:
	'CX'
;

DX_NUM
:
	'DX'
;

REG_START
:
	'['
;

REG_END
:
	']'
;

NAME
:
	[a-zA-Z\-_öäüÖÄÜßẞ]+ //TODO find unicode number of the special characters

;

CONST_POOL
:
	'::'
	(
		(
			'"'
			(
				(
					~( ["\t\r\n\\] )
				)
				|
				(
					'\\' ["trn\\]
				)
			)* '"'
		)
		|
		(
			[0-9a-fA-F]+
		)
		|
		(
			'#'[a-zA-Z\-_öäüÖÄÜßẞ]+ //TODO find unicode number of the special characters
		)
		|
		(
			[ \t\r\n]
		)
		|
		(
			'|COM:'
			(
				~( '>' )
			)* '>'
		)
		|
		(
			'|COM>'
			(
				~( [\r\n] )
			)
		)
	)* '>>'
;

BLOCK_COMMENT
:
	(
		'|COM:'
		(
			~( '>' )
		)* '>'
	) -> skip
;

LINE_COMMENT
:
	(
		'|COM>'
		(
			~( [\r\n] )
		)
	) -> skip
;

WS
:
	[ \t\r\n] -> skip
;
