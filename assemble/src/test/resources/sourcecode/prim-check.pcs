	GET_SP AX
	CMP AX, -1
	JMPNE skip_stack-init
	MOV AX, 1024
	INT ##INT-MEMORY-ALLOC
	CMP AX, -1
	JMPEQ error_1
	SET_SP AX
@skip_stack-init
	CALL main
	INT ##INT-EXIT
#file-POS --POS--
	: CHARS 'UTF-8' "./input/in2.data\0" >
#file-out-POS --POS--
	: CHARS 'UTF-8' "./output/out2-pc.data\0" >
#file-length 8
#file-numbers (##file-length / 8)
~IF (##file-length % 8 != 0)
	~ERROR {"file-length is not dividable with 8! #file-length=" #file-length }
~ENDIF
>
@main
	MOV AX, #file-length
	INT ##INT-MEMORY-ALLOC
	CMP AX, -1
	JMPEQ error_2
	MOV CX, AX
	#main-GET_IP-POS (--POS-- - ##file-POS)
	GET_IP AX
	SUB AX, ##main-GET_IP-POS
	INT ##INT-STREAMS-NEW_IN
	CMP AX, -1
	JMPEQ error_3
	MOV BX, ##file-length
	INT ##INT-STREAMS-READ
	CMP BX, ##file-length
	JMPNE error_4
	MOV AX, 32
	INT ##INT-MEMORY-ALLOC
	CMP AX, -1
	JMPEQ error_5
	MOV DX, AX
	MOV [DX + 16], CX
	MOV [DX + 24], 0
	|:	AX: for is_prim: potential-prim
	|	BX: for is_prim: result
	|	CX: for is_prim: free use/?
	|	DX:	[DX]: for is_prim: free use/?
	|		[DX+8]: for is_prim: free use/?
	|		[DX+16]: memory pointer
	|		[DX+24]: loop counter
	|:>
@main-find_prims-loop
	MOV AX, [DX + 16]
	MOV AX, [AX]
	|:	AX: potential prim num
	|	DX: points to 16 bytes memory for free use
	|
	|	AX <- ?
	|	if prim:
	|		BX <- NDEC-1
	|	if no prim:
	|		BX <- mod 0 number |> does not have to be a prim
	|	CX <- ?
	|	DX <- unchanged
	|:>
	CALL is_prim
	MOV AX, [DX + 16]
	MOV [AX], BX
	ADD [DX + 16], 8
	INC [DX + 24]
	CMP [DX + 24], ##file-numbers
	JMPLT main-find_prims-loop
	MOV DX, [DX + 16]
	SUB DX, ##file-length
	#main-GET_IP-POS (--POS-- - ##file-out-POS)
	GET_IP AX
	SUB AX, ##main-GET_IP-POS
	#main-GET_IP-POS ~DEL
	INT #INT-STREAMS-NEW_OUT
	CMP AX, -1
	JMPEQ error_6
	MOV CX, DX
	MOV BX, ##file-length
	INT ##INT-STREAMS-WRITE
	CMP BX, ##file-length
	JMPNE error_7
	MOV AX, 0
	RET

:
	#error-msg-POS --POS--
	CHARS 'UTF-8' "An error occurred\nI will exit the program now (with exit code 1) (@error_"
	|> the rest of the message is saved in the first three bytes of DX [num, ')', '\n']
	#error-msg-length (--POS-- - #error-msg-POS)
>
@error_1
	MOV DX, HEX-0A2931
	JMP error
@error_2
	MOV DX, HEX-0A2932
	JMP error
@error_3
	MOV DX, HEX-0A2933
	JMP error
@error_4
	MOV DX, HEX-0A2934
	JMP error
@error_5
	MOV DX, HEX-0A2935
	JMP error
@error_6
	MOV DX, HEX-0A2936
	JMP error
@error_7
	MOV DX, HEX-0A2936
@error
	#error-msg-POS-dif (--POS-- - ##error-msg-POS)
	GET_IP CX
	ADD CX, ##error-msg-POS-dif
	#GET_IP-POS ~DEL
	MOV BX, ##error-msg-length
	MOV AX, ##STD-LOG
	INT ##INT-STREAMS-WRITE
	MOV [CX], DX
	MOV BX, 3
	INT ##INT-STREAMS-WRITE
	MOV AX, 1
	INT ##INT-EXIT

|:
|	AX <- AX
|	BX <- wurzel(AX)
|	AX has a natural number wurzel:
|		CX <- BX * BX
|	AX has no natural number wurzel:
|		CX <- (BX + 1) * (BX + 1)
|:>
@wurzel
	MOV BX, 0
@wurzel-loop
	MOV CX, BX
	MUL CX, CX
	CMP AX, CX
	JMPEQ return
	JMPLT wurzel-ret-sub_1
	INC BX
	JMP wurzel-loop
@wurzel-ret-sub_1
	DEC BX
@return
	RET

|:
|	AX: potential prim num
|	DX: points to 16 bytes memory for free use
|
|	AX <- ?
|	if prim:
|		BX <- NDEC-1
|	if no prim:
|		BX <- mod 0 number |> does not have to be a prim
|	CX <- ?
|	DX <- unchanged
|:>
@is_prim
	CALL wurzel
	CMP AX, CX
	JMPEQ return |> BX is already set to the mod zero num
	MOV CX, AX
	AND CX, 1
	JMPZS is_prim-check_2
	MOV CX, AX
	MOV CX, BX
	MOV BX, 3
	|:	AX:			MOD
	|	BX:			check
	|	CX:			wurzel
	|	[DX]:		DIV
	|	[DX + 8]:	potential-prim
	|:>
@is_prim-loop
	CMP BX, CX
	JMPGE is_prim-ret-N1
	MOV [DX], [DX + 8]
	MOV AX, BX
	DIV [DX], AX
	CMP AX, 0
	JMPEQ return |> BX is already set to the mod zero num
	ADD BX, 2
	JMP is_prim-loop
@is_prim-check_2
	CMP AX, 2
	JMPEQ is_prim-ret-N1
	MOV BX, 2
	RET
@is_prim-ret-N1
	MOV BX, -1
	RET
