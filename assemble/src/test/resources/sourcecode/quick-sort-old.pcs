|> uses the old version.
$not_align
JMP main
int_illegal_mem_vars_POS --POS--
:
    #MAX_VALUE WRITE |> first var is stack pointer
    #MAX_VALUE WRITE |> second var is max stack size
    #MAX_VALUE WRITE |> var is for free use
    #MAX_VALUE WRITE |> var is for free use
    #MAX_VALUE WRITE |> var is for free use
>
#ADD_STACK_SIZE 1024
#INIT_STACK_SIZE ADD_STACK_SIZE
#int_illegal_mem_interrupt_POS --POS--
@int_illegal_mem_interrupt
#stack_pointer -40
#max_size -32
#free_use_BX -24
#free_use_CX -16
#free_use_DX -8
    GET_IP AX
    ADD [AX + #max_size], #ADD_STACK_SIZE
    MOV [AX + #free_use_BX], BX
    MOV [AX + #free_use_CX], CX
    MOV [AX + #free_use_DX], DX
    MOV BX , [AX + #max_size]
    MOV AX , [AX + #stack_pointer]
    MOV DX , BX
    INT #INT_MEMORY_REALLOC
    CMP BX , -1
    JMPEQ error
    GET_SP CX
    SUB CX , [DX + #stack_pointer]
    ADD BX , CX
    SET_IP BX
    MOV BX , [DX + #free_use_BX]
    MOV CX , [DX + #free_use_CX]
    MOV DX , [DX + #free_use_DX]
    IRET
#stack_pointer ~DEL
#max_size ~DEL
#free_use_A ~DEL
#free_use_B ~DEL
:
#main_file_length 1073741824
#main_file_string_POS --POS--
    CHARS 'UTF-8' "./input/in.data\0"
>
$align
@main
|>    SET_INTCNT #INTERRUPT_COUNT
    CMP AX , 1
    JMPNE error |> arguments are not allowed
    GET_SP AX
    CMP AX , -1
    JMPNE main_skip_stack_init
    MOV AX , #INIT_STACK_SIZE
    INT #INT_MEMORY_ALLOC |> endless loop here
    CMP AX , -1
    JMPEQ error
    SET_SP AX
@main_skip_stack_init
|> interrupt init
    GET_INTS AX
    CMP AX , -1
    JMPNE main_skip_interrupt_init
    MOV AX , #INTERRUPT_COUNT
    LSH AX
    LSH AX
    LSH AX
    MOV DX , AX
    INT #INT_MEMORY_ALLOC
    CMP AX , -1
    JMPEQ error
@main_interrupt_init_loop
    SUB DX , 8
    MOV [AX + DX], -1
    CMP DX , 0
    JMPGT main_interrupt_init_loop
#main_interrupt_init_memInt_Pos --POS--
    GET_IP DX
    SUB DX , #main_interrupt_init_memInt_Pos
    MOV CX , DX
    ADD CX , int_illegal_mem_vars_POS
    GET_SP BX
    MOV [CX], BX
    MOV [CX + 8], #INIT_STACK_SIZE |> TODO assembled to 'MOV [CX + 2], 1024'
    ADD DX , #int_illegal_mem_interrupt_POS
    MOV BX , #INT_ERRORS_ILLEGAL_MEMORY
    LSH BX
    LSH BX
    LSH BX
    MOV [AX + BX], DX
    SET_INTS AX
@main_skip_interrupt_init 
    MOV AX , #main_file_length
    MOV BX , AX
    INT #INT_MEMORY_ALLOC
    CMP AX , -1
    JMPEQ error
    MOV AX , CX
#main_get_ip_for_file_name_POS --POS--
    GET_IP AX
    SUB AX , #main_get_ip_for_file_name_POS
    ADD AX , #main_file_string_POS
    INT #INT_STREAMS_NEW_IN
    CMP AX , -1
    JMPEQ error
    INT #INT_STREAMS_READ
    CMP BX , #main_file_length
    JMPNE error
    MOV DX , CX
    MOV CX , BX
    CALL sort
    MOV AX , 0
    INT #INT_EXIT

|:
| DX: points to the array to be sorted
| CX: has the number of 8-byte_elements in the array
| 
| this wraps calls @sort_quick_sort to sort and frees the allocated array
|:>
@sort
    SUB CX , 1
    RASH CX
    RASH CX
    RASH CX
    CALL sort_quick_sort
    INT #INT_MEMORY_FREE
    RET
|:
|    DX: points to the array to be sorted
|    CX: has the index of the last index of the array to be sorted
|       so (CX/8)+1 is the number of 8-byte_elements in the array
|
|    DX will be unchanged
|    CX will be changed
|    BX will be changed
|    AX will be set to an array of #SIZE bytes
|:>
|>#END_I 0
#LOW_I 8
#HIGH_I 16
#SIZE 24
@sort_quick_sort
    MOV AX , #SIZE
    INT #INT_MEMORY_ALLOC
    CMP AX , -1
    JMPEQ error
|> like @sort_quick_sort, but AX is already (and will be unchanged) set to an array with the size #SIZE
@sort_quick_sort_allocated
    |> init [AX + ...]
    MOV [AX], CX
    MOV [AX + #HIGH_I], CX
    MOV [AX + #LOW_I], 0
|>    set pivot ((zero + mid + last= / 3) to CX
    RASH CX
    AND CX , NHEX-0000000000000008 |> BX := BX % 8
|:
        CMP [DX], [DX + BX] |> compare zero, mid
        JMPGT sort_quick_sort_zero_gt_mid
        CMP [DX + CX], [DX + BX] |> compare last, mid
        JMPGT sort_quick_sort_pivot_mid
    |>    zero <= mid >= last
        CMP [DX + CX], [DX]
        JMPGT sort_quick_sort_pivot_last
    |> @sort_quick_sort_pivot_zero
        MOV CX , 0
        JMP sort_quick_sort_sort_start
    @sort_quick_sort_zero_gt_mid
        CMP [DX], [DX + CX] |> compare zero, last
        JMPGT sort_quick_sort_zero_great
        CMP [DX + CX], [DX + BX] |> compare last, mid
        JMPGT sort_quick_sort_pivot_last |> zero > last > mid
        JMP sort_quick_sort_pivot_mid
    @sort_quick_sort_zero_great
        CMP [DX + BX], [DX + CX]
        JMPGT sort_quick_sort_pivot_last
    @sort_quick_sort_pivot_mid
        MOV CX , BX
    @sort_quick_sort_pivot_last |> the pivot is CX , which was the last
:>
@sort_quick_sort_sort_start |> just start with the left (the direction does not matter)
@sort_quick_sort_sort_left
|:
|    DX: array
|    CX: pivot
|    BX: free use
|    AX:
|        [AX]: end_index
|        [AX + #LOW_I]: low_index
|        [AX + #HIGH_I]: high_index
|:>
    MOV BX , [AX + #LOW_I]
    CMP BX , CX
    JMPGT sort_quick_sort_sort_right
    ADD [AX + #LOW_I], 8
    CMP [DX + BX], [DX + CX]
    JMPLE sort_quick_sort_sort_left
    MOV [AX + #LOW_I], [DX + BX] |> (low_index - 8) is in BX , so it can be used to swap
    MOV [DX + BX], [DX + CX]
    MOV [DX + CX], [AX + #LOW_I]
    ADD BX , 8
    MOV [AX + #LOW_I], BX
|>    JMP sort_quick_sort_sort_right
@sort_quick_sort_sort_right
    MOV BX , [AX + #HIGH_I]
    CMP BX , CX
    JMPLT sort_quick_sort_recursive_calls
    SUB [AX + #HIGH_I], 8
    CMP [BX], [CX]
    JMPGE sort_quick_sort_sort_right
    MOV [AX + #HIGH_I], [DX + BX] |> (high_index + 8) is in BX , so it can be used to swap
    MOV [DX + BX], [DX + CX]
    MOV [DX + CX], [AX + #HIGH_I]
    SUB BX , 8
    MOV [AX + #HIGH_I], BX
    JMP sort_quick_sort_sort_left
@sort_quick_sort_recursive_calls
|:
|    DX: the array
|    BX: free use
|    CX: pivot
|    AX:
|        [AX]: end_index
|        [AX + #LOW_I]: low_index
|        [AX + #HIGH_I]: high_index
|:>
    CMP CX , 8
    JMPLE sort_quick_sort_recursive_calls_skip_low_call
    PUSH CX
    PUSH [AX]
    |:
    |    DX: points to the array to be sorted
    |    CX: has the index of the last index of the array to be sorted
    |       so (CX / 8)+1 is the number of 8-byte_elements in the array
    |:>
    SUB CX , 8 |> last_index is pivot - 8
    CALL sort_quick_sort_allocated
    POP [AX]
    POP CX
@sort_quick_sort_recursive_calls_skip_low_call
    |> if: (end_index - pivot) > 8
    MOV BX , [AX]
    SUB BX , CX
    CMP BX , 8
    JMPLE return
    ADD DX , CX
    ADD DX , 8
    MOV CX , BX
    JMP sort_quick_sort_allocated
#LOW_I ~DEL
#HIGH_I ~DEL
|>#END_I ~DEL

@return
    RET
@error
    MOV AX , 1
    INT #INT_EXIT
