|>#AX-END_I 0
#LOW_I 8
#HIGH_I 16
#SIZE 24

|:
| DX: points to the array to be sorted
| CX: has the number of 8-byte-elements in the array
| 
| this wraps just @sort-quick_sort, but also frees the allocated array
|:>
@sort
	SUB CX, 1
	RASH CX
	RASH CX
	RASH CX
	CALL sort-quick_sort
	INT #INT-MEMORY-FREE
	RET
|:
|	DX: points to the array to be sorted
|	CX: has the index of the last index of the array to be sorted
|       so (CX/8)+1 is the number of 8-byte-elements in the array
|
|	DX will be unchanged
|	CX will be changed
|	BX will be changed
|	AX will be set to an array of #SIZE bytes
|:>
@sort-quick_sort
	MOV AX, #SIZE
	INT #INT-MEMORY-ALLOC
	CMP AX, -1
	JMPEQ error
|> like @sort-quick_sort, but AX is already (and will be unchanged) set to an array with the size #SIZE
@sort-quick_sort-allocated
	|> init [AX + ...]
	MOV [AX], CX
	MOV [AX + #HIGH_I], CX
	MOV [AX + #LOW_I], 0
|>	set pivot ((zero + mid + last= / 3) to CX
	RASH CX
	AND CX, HEX-FFFFFFFFFFFFFFF8 |> BX := BX % 8
|:	
		CMP [DX], [DX + BX] |> compare zero, mid
		JMPGT sort-quick_sort-zero_gt_mid
		CMP [DX + CX], [DX + BX] |> compare last, mid
		JMPGT sort-quick_sort-pivot_mid
	|>	zero <= mid >= last
		CMP [DX + CX], [DX]
		JMPGT sort-quick_sort-pivot_last
	|> @sort-quick_sort-pivot_zero
		MOV CX, 0
		JMP sort-quick_sort-sort-start
	@sort-quick_sort-zero_gt_mid
		CMP [DX], [DX + CX] |> compare zero, last
		JMPGT sort-quick_sort-zero_great
		CMP [DX + CX], [DX + BX] |> compare last, mid
		JMPGT sort-quick_sort-pivot_last |> zero > last > mid
		JMP sort-quick_sort-pivot_mid
	@sort-quick_sort-zero_great
		CMP [DX + BX], [DX + CX]
		JMPGT sort-quick_sort-pivot_last
	@sort-quick_sort-pivot_mid
		MOV CX, BX
	@sort-quick_sort-pivot_last |> the pivot is CX, which was the last
:>
@sort-quick_sort-sort-start |> just start with the left (the direction does not matter)
@sort-quick_sort-sort-left
|:
|	DX: array
|	CX: pivot
|	BX: free use
|	AX:
|		[AX]: end-index
|		[AX + #LOW_I]: low-index
|		[AX + #HIGH_I]: high-index
|:>
	MOV BX, [AX + #LOW_I]
	CMP BX, CX
	JMPGT sort-quick_sort-sort-right
	ADD [AX + #LOW_I], 8
	CMP [DX + BX], [DX + CX]
	JMPLE sort-quick_sort-sort-left
	MOV [AX + #LOW_I], [DX + BX] |> (low-index - 8) is in BX, so it can be used to swap
	MOV [DX + BX], [DX + CX]
	MOV [DX + CX], [AX + #LOW_I]
	ADD BX, 8
	MOV [AX + #LOW_I], BX
|>	JMP sort-quick_sort-sort-right
@sort-quick_sort-sort-right
	MOV BX, [AX + #HIGH_I]
	CMP BX, CX
	JMPLT sort-quick_sort-recursive_calls
	SUB [AX + #HIGH_I], 8
	CMP [BX], [CX]
	JMPGE sort-quick_sort-sort-right
	MOV [AX + #HIGH_I], [DX + BX] |> (high-index + 8) is in BX, so it can be used to swap
	MOV [DX + BX], [DX + CX]
	MOV [DX + CX], [AX + #HIGH_I]
	SUB BX, 8
	MOV [AX + #HIGH_I], BX
	JMP sort-quick_sort-sort-left
@sort-quick_sort-recursive_calls
|:
|	DX: the array
|	BX: free use
|	CX: pivot
|	AX:
|		[AX]: end-index
|		[AX + #LOW_I]: low-index
|		[AX + #HIGH_I]: high-index
|:>
	CMP CX, 8
	JMPLE sort-quick_sort-recursive_calls-skip_low_call
	PUSH CX
	PUSH [AX]
	|:
	|	DX: points to the array to be sorted
	|	CX: has the index of the last index of the array to be sorted
	|       so (CX/8)+1 is the number of 8-byte-elements in the array
	|:>
	SUB CX, 8 |> last-index is pivot - 8
	CALL sort-quick_sort-allocated
	POP [AX]
	POP CX
@sort-quick_sort-recursive_calls-skip_low_call
	|> if: (end-index - pivot) > 8
	MOV BX, [AX]
	SUB BX, CX
	CMP BX, 8
	JMPLE return
	ADD DX, CX
	ADD DX, 8
	MOV CX, BX
	JMP sort-quick_sort-allocated

@return
	RET
@error
	MOV AX, 1
	INT #INT-EXIT
