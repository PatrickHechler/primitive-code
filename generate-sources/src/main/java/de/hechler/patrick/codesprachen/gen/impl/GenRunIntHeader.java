//This file is part of the Primitive Code Project
//DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//Copyright (C) 2023  Patrick Hechler
//
//This program is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program.  If not, see <https://www.gnu.org/licenses/>.
package de.hechler.patrick.codesprachen.gen.impl;

import java.io.IOException;
import java.io.Writer;

import de.hechler.patrick.codesprachen.gen.SrcGen;


public class GenRunIntHeader implements SrcGen {
	
	private static final String FILE_TXT0 = "/*\n"//
			+ " * this file is automatically generated\n"//
			+ " * by the generate-sources project, do NOT modify\n"//
			+ " */\n\n"//
			+ "\n"//
			+ "#if defined SRC_PVM_INT_H_ | !defined PVM\n"//
			+ "#error \"multpile includes of pvm-int.h or PVM is not defined!\"\n"//
			+ "#endif\n"//
			+ "#define SRC_PVM_INT_H_\n"//
			+ "\n"//
			+ "#ifdef PVM_DEBUG\n"//
			+ "#\tdefine INT_PARAMS num int_num\n"//
			+ "#else\n"//
			+ "#\tdefine INT_PARAMS\n"//
			+ "#endif // PVM_DEBUG\n"//
			+ "";
	
	private static final char FILE_TXT1 = '\n';
	
	private static final String FILE_TXT2 = "\n"//
			+ "static void (*(ints[]))(INT_PARAMS) = {\n"//
			+ "";
	
	private static final String FILE_TXT3 = "};\n"//
			+ "\n"//
			+ "_Static_assert((sizeof(void (*)(INT_PARAMS)) * INTERRUPT_COUNT) == sizeof(ints), \"Error!\");\n"//
			+ "";
	
	@Override
	public void generate(Writer out) throws IOException {
		out.write(FILE_TXT0);
		int last = -1;
		for (PrimAsmConstant cnst : SrcGen.PrimAsmConstant.ALL_CONSTANTS) {
			if (cnst.name().startsWith("INT_")) {
				if (cnst.value() != ++last) {
					throw new AssertionError("interrupts not ordered a interrupt number is doubled/skipped (expected=" + last + " but git "
							+ cnst.value() + " (name='" + cnst.name() + "')");
				}
				out.write("static void ");
				out.write(cnst.name().toLowerCase());
				out.write("(INT_PARAMS); /* ");
				out.write(Long.toString(cnst.value()));
				out.write(" */\n");
			}
		}
		out.write(FILE_TXT1);
		for (PrimAsmConstant cnst : SrcGen.PrimAsmConstant.ALL_CONSTANTS) {
			if (cnst.name().startsWith("INT")) { // also print interrupt count
				out.write("#define ");
				out.write(cnst.name());
				out.write(' ');
				out.write(Long.toString(cnst.value()));
				out.write('\n');
			}
		}
		out.write(FILE_TXT2);
		for (PrimAsmConstant cnst : SrcGen.PrimAsmConstant.ALL_CONSTANTS) {
			if (cnst.name().startsWith("INT_")) {
				out.write('\t');
				out.write(cnst.name().toLowerCase());
				out.write(", /* ");
				out.write(Long.toString(cnst.value()));
				out.write(" */\n");
			}
		}
		out.write(FILE_TXT3);
	}
	
}
