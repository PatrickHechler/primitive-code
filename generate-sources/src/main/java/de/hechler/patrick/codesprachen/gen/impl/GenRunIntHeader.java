//This file is part of the Patr File System and Code Projects
//DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//Copyright (C) 2023  Patrick Hechler
//
//This program is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program.  If not, see <https://www.gnu.org/licenses/>.
package de.hechler.patrick.codesprachen.gen.impl;

import java.io.IOException;
import java.io.Writer;

import de.hechler.patrick.codesprachen.gen.SrcGen;


public class GenRunIntHeader implements SrcGen {
	
	private static final String FILE_TXT0 = //
		"/*\n"//
			+ " * this file is automatically generated\n"//
			+ " * by the generate-sources project, do NOT modify\n"//
			+ " */\n\n"//
			+ "\n"//
			+ "#ifdef SRC_PVM_INT_H_\n"//
			+ "#\tifdef PVM\n"//
			+ "#\t\terror \"Multiple includes of pvm-cmd-cmds-gen.h and PVM is defined!\"\n"//
			+ "#\tendif\n"//
			+ "#else // SRC_PVM_INT_H_\n"//
			+ "#define SRC_PVM_INT_H_\n"//
			+ "\n"//
			+ "#ifdef PVM\n"//
			+ "\n"//
			+ "";
	
	private static final String FILE_TXT1 = "\n"//
		+ "#endif // PVM\n"//
		+ "\n";
	
	private static final String FILE_TXT2 = "\n"//
		+ "EXT void (*(ints[]))(INT_PARAMS)\n"
		+ "#ifdef PVM\n"
		+ " = {\n"//
		+ "";
	
	private static final String FILE_TXT3 = "}\n"
		+ "#endif // PVM\n"
		+ ";\n"//
		+ "\n"//
		+ "#ifdef PVM\n"
		+ "_Static_assert((sizeof(void (*)(INT_PARAMS)) * INTERRUPT_COUNT) == sizeof(ints), \"Error!\");\n"//
		+ "#endif // PVM\n"
		+ "";
	
	@Override
	public void generate(Writer out) throws IOException {
		out.write(FILE_TXT0);
		int last = -1;
		for (PrimAsmConstant cnst : SrcGen.PrimAsmConstant.ALL_CONSTANTS) {
			if (cnst.name().startsWith("INT_")) {
				if (cnst.value() != ++last) {
					throw new AssertionError("interrupts not ordered a interrupt number is doubled/skipped (expected=" + last + " but git " + cnst.value()
						+ " (name='" + cnst.name() + "')");
				}
				out.write("static void ");
				out.write(cnst.name().toLowerCase());
				out.write("(INT_PARAMS); /* ");
				out.write(Long.toString(cnst.value()));
				out.write(" */\n");
			}
		}
		out.write(FILE_TXT1);
		for (PrimAsmConstant cnst : SrcGen.PrimAsmConstant.ALL_CONSTANTS) {
			if (cnst.name().startsWith("INT")) { // also print interrupt count
				out.write("#define ");
				out.write(cnst.name());
				out.write(' ');
				out.write(Long.toString(cnst.value()));
				out.write('\n');
			}
		}
		out.write(FILE_TXT2);
		for (PrimAsmConstant cnst : SrcGen.PrimAsmConstant.ALL_CONSTANTS) {
			if (cnst.name().startsWith("INT_")) {
				out.write('\t');
				out.write(cnst.name().toLowerCase());
				out.write(", /* ");
				out.write(Long.toString(cnst.value()));
				out.write(" */\n");
			}
		}
		out.write(FILE_TXT3);
	}
	
}
