<!DOCTYPE html []>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="author" content="MarkdownViewer++" />
    <title>README.md</title>
    <style type="text/css">
            
/* Avoid page breaks inside the most common attributes, especially for exports (i.e. PDF) */
td, h1, h2, h3, h4, h5, p, ul, ol, li {
    page-break-inside: avoid; 
}

        </style>
  </head>
  <body>
    <h1 id="primitive-code">primitive-code</h1>
    <p>a register based assembler language</p>
    <p>this is the assembler-language for the Primitive-Virtual-Machine</p>
    <h2 id="start">Start</h2>
    <ul>
      <li>A primitive-assembler-code file can be assembled to a primitive-machine-code file.</li>
      <li>A primitive-machine-code file can be executed with a primitive-virtual-machine.
<ul><li>the <code>AX</code> register will be set to the number of arguments</li><li>the <code>BX</code> register will point to the arguments</li><li>the arguments will point to STRINGs
<ul><li>the first argument will be the program itself, all beyond will be the arguments of the program</li><li>example:
<ul><li><code>my_program.pmc --example value --other=val</code></li><li><code>AX &lt;- 4</code></li><li><code>[BX] &lt;- ADDRESS_OF "my_program.pmc\0"</code></li><li><code>[BX + 8] &lt;- ADDRESS_OF "--example\0"</code></li><li><code>[BX + 16] &lt;- ADDRESS_OF "value\0"</code></li><li><code>[BX + 24] &lt;- ADDRESS_OF "--other=val\0"</code></li></ul></li></ul></li><li>the <code>INTCNT</code> register will be set to <code>#INTERRUPT_COUNT</code></li><li>the interrupt-table of <code>INTP</code> will be initialized and every entry will be set to <code>-1</code><ul><li>so by default the default interrupts will be called, but they can be easily overwritten</li></ul></li></ul></li>
    </ul>
    <h2 id="primitive-virtual-machine">Primitive virtual machine</h2>
    <ul>
      <li>the primitive virtual machine has the following registers:
<ul><li><code>[A-D]X</code><ul><li>4 * 64-bit</li><li>number registers, for free use</li></ul></li><li><code>IP</code><ul><li><code>64-bit</code></li><li>the instruction pointer points to the command to be executed</li></ul></li><li><code>STATUS</code><ul><li><code>64-bit</code></li><li>saves some results of operations</li><li><code>HEX-0000000000000001</code> : <code>LOWER</code>: if on the last <code>CMP A, B</code> A was lower than B</li><li><code>HEX-0000000000000002</code> : <code>GREATHER</code>: if on the last <code>CMP A, B</code> A was greater than B</li><li><code>HEX-0000000000000004</code> : <code>CARRY</code>: if an overflow was detected</li><li><code>HEX-0000000000000008</code> : <code>ZERO</code>: if the last arithmetic or logical operation leaded to zero (<code>HEX-0000000000000000</code>)</li></ul></li><li><code>INTCNT</code><ul><li><code>64-bit</code></li><li>saves the number of allowed interrupts (<code>0..(INTCNT-1)</code> are allowed)
<ul><li>all other will call the <code>INT-ERRORS_ILLEGAL_INTERRUPT</code> interrupt</li></ul></li></ul></li><li><code>INTP</code><ul><li><code>64-bit</code></li><li>points to the interrupt-table</li></ul></li></ul></li>
    </ul>
    <h2 id="constants">CONSTANTS:</h2>
    <p>except for the <code>--POS--</code> constant all other constants can be overwritten and removed</p>
<pre><ui><li><code>--POS-- :                           </code>the position from the begin of the next command</li><li><code>#INT-ERRORS-UNKNOWN_COMMAND :       0</code></li><li><code>#INT-ERRORS-ILLEGAL_INTERRUPT :     1</code></li><li><code>#INT-ERRORS-ILLEGAL_MEMORY :        2</code></li><li><code>#INT-ERRORS-ARITHMETIC_ERROR :      3</code></li><li><code>#INT-EXIT :                         4</code></li><li><code>#INT-MEMORY-ALLOC :                 5</code></li><li><code>#INT-MEMORY-REALLOC :               6</code></li><li><code>#INT-MEMORY-FREE :                  7</code></li><li><code>#INT-STREAMS-NEW_IN :               8</code></li><li><code>#INT-STREAMS-NEW_OUT :              9</code></li><li><code>#INT-STREAMS-NEW_APPEND :           10</code></li><li><code>#INT_STREAMS-NEW_IN_OUT :           11</code></li><li><code>#INT-STREAMS-NEW_APPEND_IN_OUT :    12</code></li><li><code>#INT-STREAMS-WRITE :                13</code></li><li><code>#INT-STREAMS-READ :                 14</code></li><li><code>#INT-STREAMS-CLOSE_STREAM :         15</code></li><li><code>#INT-STREAMS-GET_POS :              16</code></li><li><code>#INT-STREAMS-SET_POS :              17</code></li><li><code>#INT-STREAMS-SET_POS_TO_END :       18</code></li><li><code>#INT-STREAMS-REM :                  19</code></li><li><code>#INT-STREAMS-MK_DIR :               20</code></li><li><code>#INT-STREAMS-REM_DIR :              21</code></li><li><code>#INT-TIME-GET :                     22</code></li><li><code>#INT-TIME-WAIT :                    23</code></li><li><code>#INT-RANDOM :                       24</code></li><li><code>#INT-SOCKET-CLIENT-CREATE :         25</code></li><li><code>#INT-SOCKET-CLIENT-CONNECT :        26</code></li><li><code>#INT-SOCKET-SERVER-CREATE :         27</code></li><li><code>#INT-SOCKET-SERVER-LISTEN :         28</code></li><li><code>#INT-SOCKET-SERVER-ACCEPT :         29</code></li><li><code>#INTERRUPT_COUNT :                  30</code></li><li><code>#MAX-VALUE :                    HEX-7FFFFFFFFFFFFFFF</code></li><li><code>#MIN-VALUE :                   NHEX-8000000000000000</code></li><li><code>#STD-IN :                           0</code></li><li><code>#STD-OUT :                          1</code></li><li><code>#STD-LOG :                          2</code></li><li><code>#FP-NAN :                       HEX-7FFE000000000000</code></li><li><code>#FP-MAX-VALUE :                 HEX-7FEFFFFFFFFFFFFF</code></li><li><code>#FP-MIN-VALUE :                 HEX-0000000000000001</code></li><li><code>#FP-POS-INFINITY :              HEX-7FF0000000000000</code></li><li><code>#FP-NEG-INFINITY :             NHEX-7FF0000000000000</code></li></ui></pre>    <h2 id="status">STATUS:</h2>
    <ul>
      <li>the status register has some flags which are initialized with random values
<ul><li><code>LOWER</code></li><li><code>GREATHER</code></li><li><code>CARRY</code></li></ul></li>
    </ul>
    <h2 id="strings">STRINGS:</h2>
    <ul>
      <li>if any command, function or whatever of primitive-code refers to STRING(s) this definition is used</li>
      <li>a string is an array of multiple characters of the UTF-8 encoding</li>
      <li>a string ends with a '\0' character</li>
    </ul>
    <h2 id="commands">COMMANDS:</h2>
    <p>
      <code>MOV &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>copies the value of the second parameter to the first parameter
<ul><li><code>p1 &lt;- p2</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>ADD &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>adds the values of both parameters and stores the sum in the first parameter
<ul><li><code>if ((p1 &gt; 0) &amp; (p2 &gt; 0) &amp; ((p1 + p2) &lt; 0)) | ((p1 &lt; 0) &amp; (p2 &lt; 0) &amp; ((p1 + p2) &gt; 0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 + p2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>ADDC &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>adds the values of both parameters and the carry flag and stores the sum in the first parameter
<ul><li><code>if ((p1 &gt; 0) &amp; ((p2 + CARRY) &gt; 0) &amp; ((p1 + p2 + CARRY) &lt; 0)) | ((p1 &lt; 0) &amp; ((p2 + CARRY) &lt; 0) &amp; ((p1 + (p2 + CARRY)) &gt; 0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 + (p2 + CARRY)</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>ADDFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>adds the floating point values of both parameters and stores the floating point sum in the first parameter
<ul><li><code>if ((p1 &gt; 0.0) &amp; (p2 &gt; 0.0) &amp; ((p1 + p2) &lt; 0.0)) | ((p1 &lt; 0.0) &amp; (p2 &lt; 0.0) &amp; ((p1 + p2) &gt; 0.0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 fp-add p2</code></li><li><code>if p1 = 0.0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>SUB &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>subtracts the second parameter from the first parameter and stores the result in the first parameter
<ul><li><code>if ((p1 &gt; 0) &amp; (p2 &lt; 0) &amp; ((p1 - p2) &lt; 0)) | ((p1 &lt; 0) &amp; (p2 &gt; 0) &amp; ((p1 - p2) &gt; 0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 - p2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>SUBC &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>subtracts the second parameter with the carry flag from the first parameter and stores the result in the first parameter
<ul><li><code>if (p1 &gt; 0) &amp; ((p2 + CARRY) &lt; 0) &amp; ((p1 - (p2 + CARRY)) &lt; 0)) | ((p1 &lt; 0) &amp; (p2 &gt; 0) &amp; ((p1 - (p2 + CARRY)) &gt; 0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 - (p2 + CARRY)</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>SUBFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>subtracts the second fp-parameter from the first fp-parameter and stores the fp-result in the first fp-parameter
<ul><li><code>if ((p1 &gt; 0) &amp; (p2 &lt; 0) &amp; ((p1 fp-sub p2) &lt; 0)) | ((p1 &lt; 0) &amp; (p2 &gt; 0) &amp; ((p1 fp-sub p2) &gt; 0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 fp-sub p2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>MUL &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>multiplies the first parameter with the second and stores the result in the first parameter
<ul><li><code>if (((p1 &gt; 0) &amp; (p2 &gt; 0) | (p1 &lt; 0) &amp; (p2 &lt; 0)) &amp; ((p1 * p2) &lt; 0)) | (((p1 &gt; 0) &amp; (p2 &lt; 0) | (p1 &lt; 0) &amp; (p2 &gt; 0)) &amp; ((p1 * p2) &gt; 0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 * p2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>MULFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>multiplies the first fp parameter with the second fp and stores the fp result in the first parameter
<ul><li><code>if (((p1 &gt; 0.0) &amp; (p2 &gt; 0.0) | (p1 &lt; 0.0) &amp; (p2 &lt; 0.0)) &amp; ((p1 fp-mul p2) &lt; 0.0)) | (((p1 &gt; 0.0) &amp; (p2 &lt; 0.0) | (p1 &lt; 0.0) &amp; (p2 &gt; 0.0)) &amp; ((p1 fp-mul p2) &gt; 0.0))</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 fp-mul p2</code></li><li><code>if p1 = 0.0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>DIV &lt;NO_CONST_PARAM&gt; , &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>divides the first parameter with the second and stores the result in the first parameter and the reminder in the second parameter
<ul><li><code>p1 &lt;- p1 / p2</code></li><li><code>p2 &lt;- p1 mod p2</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>DIVFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>divides the first fp-parameter with the second fp and stores the fp-result in the first fp-parameter
<ul><li><code>p1 &lt;- p1 fp-div p2</code></li><li><code>if p1 = 0.0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>AND &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>uses the logical AND operator with the first and the second parameter and stores the result in the first parameter
<ul><li><code>p1 &lt;- p1 &amp; p2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>OR &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>uses the logical OR operator with the first and the second parameter and stores the result in the first parameter
<ul><li><code>p1 &lt;- p1 | p2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>XOR &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>uses the logical OR operator with the first and the second parameter and stores the result in the first parameter
<ul><li><code>p1 &lt;- p1 ^ p2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>LSH &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>shifts bits of the parameter logically left</li>
      <li>this effectively multiplies the parameter with two
<ul><li><code>if (p1 | NHEX-8000000000000000) = p1</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 * 2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>RLSH &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>shifts bits of the parameter logically right
<ul><li><code>if (p1 | HEX-0000000000000001) = p1</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 &gt;&gt; 1</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>RASH &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>shifts bits of the parameter arithmetic right</li>
      <li>this effectively divides the parameter with two
<ul><li><code>if (p1 | HEX-0000000000000001) = p1</code><ul><li><code>CARRY &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li></ul></li><li><code>p1 &lt;- p1 / 2</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>NOT &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>uses the logical NOT operator with every bit of the parameter and stores the result in the parameter</li>
      <li>this instruction works like <code>XOR p1, -1</code><ul><li><code>p1 &lt;- ~ p1</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>NEG &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>uses the arithmetic negation operation with the parameter and stores the result in the parameter</li>
      <li>this instruction works like <code>MUL p1, -1</code><ul><li><code>if p1 = #MIN-VALUE</code><ul><li><code>CARRY &lt;- 1</code></li><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li><li><code>p1 &lt;- 0 - p1</code></li><li><code>if p1 = 0</code><ul><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>ZERO &lt;- 0</code></li></ul></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>JMP &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label
<ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPEQ &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last compare operation compared two equal values
<ul><li><code>if ( ! GREATHER) &amp; ( ! LOWER)</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPNE &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last compare operation compared two different values
<ul><li><code>if GREATHER | LOWER</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPGT &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last compare result was greater
<ul><li><code>if GREATHER</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPGE &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last compare result was not lower
<ul><li><code>if ! LOWER</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPLT &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last compare result was lower
<ul><li><code>if LOWER</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPLE &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last compare result was not greater
<ul><li><code>if ! GREATHER</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPCS &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last carry flag is set
<ul><li><code>if CARRY</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPCC &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last carry flag is cleared
<ul><li><code>if ! CARRY</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPZS &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last zero flag is set
<ul><li><code>if ZERO</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>JMPZC &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last zero flag is cleared
<ul><li><code>if ! ZERO</code><ul><li><code>IP &lt;- IP - --POS-- + LABEL</code></li></ul></li><li><code>else</code><ul><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>CALL &lt;LABEL&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to position of the command after the label if the last compare result was not greater
<ul><li><code>[SP] &lt;- IP</code></li><li><code>SP &lt;- SP + 1</code></li><li><code>IP &lt;- IP - --POS-- + LABEL</code></li><li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li></ul></li>
    </ul>
    <p>
      <code>CMP &lt;PARAM&gt; , &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>compares the two values and stores the result in the status register
<ul><li><code>if p1 &lt; p2</code><ul><li><code>LOWER &lt;- 1</code></li><li><code>GREATHER &lt;- 0</code></li></ul></li><li><code>if p1 &gt; p2</code><ul><li><code>LOWER &lt;- 0</code></li><li><code>GREATHER &lt;- 1</code></li></ul></li><li><code>if p1 = p2</code><ul><li><code>LOWER &lt;- 0</code></li><li><code>GREATHER &lt;- 0</code></li></ul></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>RET</code>
    </p>
    <ul>
      <li>sets the instruction pointer to the position which was secured in the stack
<ul><li><code>IP &lt;- [SP]</code></li><li><code>SP &lt;- SP - 1</code></li></ul></li>
    </ul>
    <p>
      <code>IRET</code>
    </p>
    <ul>
      <li>returns from an interrupt
<ul><li><code>STATUS &lt;- BX</code></li><li><code>IP &lt;- CX</code></li><li><code>AX &lt;- [DX]</code></li><li><code>BX &lt;- [DX + 8]</code></li><li><code>CX &lt;- [DX + 16]</code></li><li><code>DX &lt;- [DX + 24]</code></li><li><code>FREE DX</code><ul><li>this does not call the interrupt, which is used to free allocated memory, but is compatible to the interrupt, which is used for allocating memory</li></ul></li></ul></li>
    </ul>
    <p>
      <code>INT &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>calls the interrupt specified by the parameter
<ul><li><code>ZW &lt;- MEM-ALLOC{size=32}</code></li><li><code>[ZW + 24] &lt;- DX</code></li><li><code>DX &lt;- ZW</code></li><li><code>[DX + 16] &lt;- CX</code></li><li><code>[DX + 8] &lt;- BX</code></li><li><code>[DX] &lt;- AX</code></li><li><code>CX &lt;- IP + CMD_LEN</code></li><li><code>BX &lt;- STATUS</code><ul><li>if the interrupt is automatically called:
<ul><li><code>CX</code> is set to the <code>IP</code> (<code>CX &lt;- IP</code>)
<ul><li>so the program does not think the operation succeeded</li><li>(for example because of a division with zero or an illegal memory access)</li></ul></li><li>the registers are saved before the 'params' were set
<ul><li>so after the <code>IRET</code> the program has its original state</li><li>interrupts with more than one 'param' are not called automatically
<ul><li>error interrupts can be called automatically (from <code>0</code> to <code>3</code> (both inclusive))</li><li>the exit interrupt´can be called automatically (when an default error interrupt is called) (<code>4</code>)
<ul><li>if automatically called the return value 'param' is never <code>0</code></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><code>IP &lt;- [INTS + (PARAM * 8)]</code></li></ul></li>
      <li>an interrupt can be overwritten:
<ul><li>with <code>GET_INTS</code> the interrupt-table can be received</li><li>to overwrite the interrupt <code>N</code>, write to <code>N * 8</code> the absolute position of address</li><li>example:
<ul><li><code>PUSH AX</code> |&gt; only needed when the value of <code>AX</code> should not be overwritten</li><li><code>PUSH BX</code> |&gt; only needed when the value of <code>BX</code> should not be overwritten</li><li><code>GET_IP AX</code> |&gt; this and the next command is not needed if the absolute position is already known</li><li><code>ADD AX, #RELATIVE-POS-FROM-GET-TO-INTERRUPT</code></li><li><code>GET_INTS BX</code> |&gt; unneeded if the interrupt table is already known</li><li><code>MOV [BX + #OVERWRITE-INT_NUM-MULTIPLIED-WITH_8], AX</code></li><li><code>POP BX</code> |&gt; only needed when the value of <code>BX</code> should not be overwritten</li><li><code>POP AX</code> |&gt; only needed when the value of <code>AX</code> should not be overwritten</li></ul></li></ul></li>
      <li>default interrupts:
<ul><li><code>0</code>: unknown command
<ul><li><code>AX</code> contains the illegal command</li><li>calls the exit interrupt with <code>9</code></li></ul></li><li><code>1</code>: illegal interrupt
<ul><li><code>AX</code> contains the number of the illegal interrupt</li><li>calls the exit interrupt with <code>7</code></li><li>if this interrupt is tried to bee called, but it is forbidden to call this interrupt, the program exits with <code>8</code></li><li>if the forbidden interrupt is the exit input, the program exits with <code>8</code></li></ul></li><li><code>2</code>: illegal memory
<ul><li>calls the exit interrupt with <code>6</code></li></ul></li><li><code>3</code>: arithmetic error
<ul><li>calls the exit interrupt with <code>5</code></li></ul></li><li><code>4</code>: exit
<ul><li>use <code>AX</code> to specify the exit number of the progress</li></ul></li><li><code>5</code>: allocate a memory-block
<ul><li><code>AX</code> saves the size of the block</li><li>if the value of <code>AX</code> is <code>-1</code> after the call the memory-block could not be allocated</li><li>if the value of <code>AX</code> is not <code>-1</code>, <code>AX</code> points to the first element of the allocated memory-block</li></ul></li><li><code>6</code>: reallocate a memory-block
<ul><li><code>AX</code> points to the memory-block</li><li><code>BX</code> saves the new size of the memory-block</li><li>if the value of <code>BX</code> is <code>-1</code> after the call the memory-block could not be reallocated, the old memory-block will remain valid and may be used and should be freed if it is not longer needed</li><li>if the value of <code>BX</code> is not <code>-1</code>, <code>BX</code> points to the first element of the allocated memory-block and the old memory-block was automatically freed, so it should not be used</li></ul></li><li><code>7</code>: free a memory-block
<ul><li><code>AX</code> points to the old memory-block</li><li>after this the memory-block should not be used</li></ul></li><li><code>8</code>: open new in stream
<ul><li><code>AX</code> contains a pointer to the STRING, which refers to the file which should be read</li><li>opens a new in stream to the specified file</li><li>is successfully the STREAM-ID will be saved in the <code>AX</code> register, if not <code>AX</code> will contain <code>-1</code></li><li>output operations are not supported on the new stream</li></ul></li><li><code>9</code>: open new out stream
<ul><li><code>AX</code> contains a pointer to the STRING, which refers to the file which should be created</li><li>opens a new out stream to the specified file</li><li>if the file exist already it's contend will be overwritten</li><li>is successfully the STREAM-ID will be saved in the <code>AX</code> register, if not <code>AX</code> will contain <code>-1</code></li><li>input operations are not supported on the new stream</li></ul></li><li><code>10</code>: open new out, append stream
<ul><li><code>AX</code> contains a pointer to the STRING, which refers to the file which should be created</li><li>opens a new out stream to the specified file</li><li>if the file exist already it's contend will be overwritten</li><li>is successfully the STREAM-ID will be saved in the <code>AX</code> register, if not <code>AX</code> will contain <code>-1</code></li></ul></li><li><code>11</code>: open new in/out stream
<ul><li><code>AX</code> contains a pointer to the STRING, which refers to the file which should be created</li><li>opens a new out stream to the specified file</li><li>if the file exist already it's contend will be overwritten</li><li>is successfully the STREAM-ID will be saved in the <code>AX</code> register, if not <code>AX</code> will contain <code>-1</code></li></ul></li><li><code>12</code>: open new in/out, append stream
<ul><li><code>AX</code> contains a pointer to the STRING, which refers to the file which should be created</li><li>opens a new out stream to the specified file</li><li>if the file exist already it's contend will be overwritten</li><li>is successfully the STREAM-ID will be saved in the <code>AX</code> register, if not <code>AX</code> will contain <code>-1</code></li></ul></li><li><code>13</code>: write
<ul><li><code>AX</code> contains the STREAM-ID</li><li><code>BX</code> contains the number of elements to write</li><li><code>CX</code> points to the elements to write</li><li>after execution <code>BX</code> will contain the number of written elements</li></ul></li><li><code>14</code>: read
<ul><li><code>AX</code> contains the STREAM-ID</li><li><code>BX</code> contains the number of elements to read</li><li><code>CX</code> points to the elements to read</li><li>after execution <code>BX</code> will contain the number of elements, which has been read.</li></ul></li><li><code>15</code>: close stream
<ul><li><code>AX</code> contains the STREAM-ID</li><li>if the stream was closed successfully <code>AX</code> will contain <code>1</code>, if not <code>0</code></li></ul></li><li><code>16</code>: get stream pos
<ul><li><code>AX</code> contains the STREAM-ID</li><li><code>BX</code> will contain the position of the stream or <code>-1</code> if something went wrong.</li><li>if the stream-ID is the ID of a default or input stream the behavior is undefined.</li></ul></li><li><code>17</code>: set stream pos
<ul><li><code>AX</code> contains the STREAM-ID</li><li><code>BX</code> contains the position to be set.</li><li>if the stream-ID is the ID of a default stream the behavior is undefined.</li><li><code>BX</code> will contain the new stream position.</li></ul></li><li><code>18</code>: set stream to end
<ul><li><code>AX</code> contains the STREAM-ID</li><li>this will set the stream position to the end</li><li><code>BX</code> will the new file pos or <code>-1</code> if something went wrong</li><li>if the stream-ID is the ID of a default or input stream the behavior is undefined.</li></ul></li><li><code>19</code>: remove file
<ul><li><code>AX</code> contains a pointer of a STRING with the file</li><li>if the file was successfully removed <code>AX</code> will contain <code>1</code>, if not <code>0</code></li></ul></li><li><code>20</code>: make dictionary
<ul><li><code>AX</code> contains a pointer of a STRING with the dictionary</li><li>if the dictionary was successfully created <code>AX</code> will contain <code>1</code>, if not <code>0</code></li></ul></li><li><code>21</code>: remove dictionary
<ul><li><code>AX</code> contains a pointer of a STRING with the dictionary</li><li>if the dictionary was successfully removed <code>AX</code> will contain <code>1</code>, if not <code>0</code></li><li>if the dictionary is not empty this call will fail (and set <code>AX</code> to <code>0</code>)</li></ul></li><li><code>22</code>: to get the time in nanoseconds
<ul><li><code>AX</code> will contain the time in nanoseconds or <code>-1</code> if not available</li></ul></li><li><code>23</code>: to wait the given time in nanoseconds
<ul><li><code>AX</code> contain the number of nanoseconds to wait</li><li><code>AX</code> will contain the number of remaining nanoseconds (or <code>0</code> if it finished waiting) or <code>-1</code> on an error</li><li><code>AX</code> will not be negative if the progress waited too long</li></ul></li><li><code>24</code>: random
<ul><li><code>AX</code> will be filled with random bits</li></ul></li><li><code>25</code>: socket client create
<ul><li>makes a new client socket</li><li><code>AX</code> will be set to the SOCKET-ID or <code>-1</code> if the operation failed</li></ul></li><li><code>26</code>: socket client connect
<ul><li><code>AX</code> points to the SOCKET-ID</li><li><code>BX</code> points to a STRING, which names the host</li><li><code>CX</code> contains the port</li><li>connects an client socket to the host on the port</li><li><code>BX</code> will be set to the <code>1</code> on success and <code>0</code> on a fail</li><li>on success, the SOCKET-ID, can be used as a STREAM-ID</li></ul></li><li><code>27</code>: socket server create
<ul><li><code>AX</code> contains the port</li><li>makes a new server socket</li><li><code>AX</code> will be set to the SOCKET-ID or <code>-1</code> when the operation fails</li></ul></li><li><code>28</code>: socket server listens
<ul><li><code>AX</code> contains the SOCKET-ID</li><li><code>BX</code> contains the MAX_QUEUE length</li><li>let a server socket listen</li><li><code>BX</code> will be set to <code>1</code> or <code>0</code> when the operation fails</li></ul></li><li><code>29</code>: socket server accept
<ul><li><code>AX</code> contains the SOCKET-ID</li><li>let a server socket accept a client</li><li>this operation will block, until a client connects</li><li><code>BX</code> will be set a new SOCKET-ID, which can be used as STREAM-ID, or <code>-1</code></li></ul></li></ul></li>
    </ul>
    <p>
      <code>PUSH &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>pushes the parameter to the stack
<ul><li><code>SP &lt;- SP + 1</code></li><li><code>[SP] &lt;- p</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>POP &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>pops the highest value from the stack to the parameter
<ul><li><code>p &lt;- [SP]</code></li><li><code>SP &lt;- SP - 1</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>SET_INTS &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>sets the interrupt pointer to the parameter
<ul><li><code>INTS &lt;- p</code></li></ul></li>
    </ul>
    <p>
      <code>SET_IP &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>sets the instruction pointer to the parameter
<ul><li><code>IP &lt;- p</code></li></ul></li>
    </ul>
    <p>
      <code>SET_SP &lt;PARAM&gt;</code>
    </p>
    <ul>
      <li>sets the stack pointer to the parameter
<ul><li><code>SP &lt;- p</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>GET_INTS &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>copies the interrupt pointer to the parameter
<ul><li><code>p &lt;- INTS</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>GET_IP &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>copies the instruction pointer to the parameter
<ul><li><code>p &lt;- IP</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
      <li>note, that the instruction pointer will modify as result of this command
<ul><li>the written value will be the instruction pointer directly before this command</li><li>so you can use <code>SET_IP</code> to land at this command (<code>GET_IP</code>)</li></ul></li>
    </ul>
    <p>
      <code>GET_SP &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>copies the stack pointer to the parameter
<ul><li><code>p &lt;- SP</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>INC &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>increments the param by one
<ul><li><code>if p = MAX-VALUE</code><ul><li><code>CARRY &lt;- 1</code></li><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li><li><code>ZERO &lt;- 0</code></li></ul></li><li><code>p &lt;- p + 1</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <p>
      <code>DEC &lt;NO_CONST_PARAM&gt;</code>
    </p>
    <ul>
      <li>decrements the param by one
<ul><li><code>if p = MIN-VALUE</code><ul><li><code>CARRY &lt;- 1</code></li><li><code>ZERO &lt;- 1</code></li></ul></li><li><code>else</code><ul><li><code>CARRY &lt;- 0</code></li><li><code>ZREO &lt;- 0</code></li></ul></li><li><code>p &lt;- p - 1</code></li><li><code>IP &lt;- IP + CMD_LEN</code></li></ul></li>
    </ul>
    <h2 id="not-yet-theresupported">not (yet) there/supported</h2>
    <ul>
      <li>execute other programs</li>
      <li>Multi-threading/-progressing</li>
    </ul>
  </body>
</html>
