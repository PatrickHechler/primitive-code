|: illegal interrupt
|    * `X00` contains the number of the illegal interrupt
|    * exits with `(128 + illegal_interrup_number)` (without calling the exit interrupt)
|    * if this interrupt is tried to bee called, but it is forbidden to call this interrupt, the program exits with `128`
INT_ERRORS_ILLEGAL_INTERRUPT=0
|: unknown command
|    * exits with `7` (without calling the exit interrupt)
INT_ERRORS_UNKNOWN_COMMAND=1
|: illegal memory
|    * exits with `6` (without calling the exit interrupt)
INT_ERRORS_ILLEGAL_MEMORY=2
|: arithmetic error
|    * exits with `5` (without calling the exit interrupt)
INT_ERRORS_ARITHMETIC_ERROR=3
|: exit
|    * use `X00` to specify the exit number of the progress
INT_EXIT=4
|: allocate a memory-block
|    * `X00` saves the size of the block
|    * if the value of `X00` is `-1` after the call the memory-block could not be allocated
|    * if the value of `X00` is not `-1`, `X00` points to the first element of the allocated memory-block
INT_MEMORY_ALLOC=5
|: reallocate a memory-block
|    * `X00` points to the memory-block
|    * `X01` is set to the new size of the memory-block
|    * `X01` will be `-1` if the memory-block could not be reallocated, the old memory-block will remain valid and should be freed if it is not longer needed
|    * `X01` will point to the new memory block, the old memory-block was automatically freed, so it should not be used, the new block should be freed if it is not longer needed
INT_MEMORY_REALLOC=6
|: free a memory-block
|    * `X00` points to the old memory-block
|    * after this the memory-block should not be used
INT_MEMORY_FREE=7
|: open new stream
|    * `X00` contains a pointer to the STRING, which refers to the file which should be read
|    * `X01` specfies the open mode: (bitwise flags)
|        * `OPEN_ONLY_CREATE`
|            * fail if the file/pipe exist already
|            * when this flags is set either `OPEN_FILE` or `OPEN_PIPE` has to be set
|        * `OPEN_ALSO_CREATE`
|            * create the file/pipe if it does not exist, but do not fail if the file/pipe exist already (overwritten by PFS_SO_ONLY_CREATE)
|        * `OPEN_FILE`
|            * fail if the element is a pipe and if a create flag is set create a file if the element does not exist already
|            * this flag is not compatible with `OPEN_PIPE`
|        * `OPEN_PIPE`
|            * fail if the element is a file and if a create flag is set create a pipe
|            * this flag is not compatible with `OPEN_FILE`
|        * `OPEN_READ`
|            * open the stream for read access
|        * `OPEN_WRITE`
|            * open the stream for write access
|        * `OPEN_APPEND`
|            * open the stream for append access (before every write operation the position is set to the end of the file)
|            * implicitly also sets `OPEN_WRITE` (for pipes there is no diffrence in `OPEN_WRITE` and `OPEN_APPEND`)
|        * `OPEN_FILE_TRUNCATE`
|            * truncate the files content
|            * implicitly sets `OPEN_FILE`
|            * nop when also `OPEN_ONLY_CREATE` is set
|        * `OPEN_FILE_EOF`
|            * set the position initially to the end of the file not the start
|            * ignored when opening a pipe
|        * other flags will be ignored
|        * the operation will fail if it is not spezified if the file should be opened for read, write and/or append
|    * opens a new stream to the specified file
|    * if successfully the STREAM-ID will be saved in the `X00` register
|    * if failed `X00` will contain `-1`
|    * to close the stream use the stream close interrupt (`INT_STREAM_CLOSE`)
INT_OPEN_STREAM=8
|: write
|    * `X00` contains the STREAM-ID
|    * `X01` contains the number of elements to write
|    * `X02` points to the elements to write
|    * `X01` will be set to the number of written bytes.
INT_STREAMS_WRITE=9
|: read
|    * `X00` contains the STREAM-ID
|    * `X01` contains the number of elements to read
|    * `X02` points to the elements to read
|    * after execution `X01` will contain the number of elements, which has been read.
|        * when the value is less than len either an error occured or end of file/pipe has reached (which is not considered an error)
INT_STREAMS_READ=10
|: stream close
|    * `X00` contains the STREAM-ID
|    * `X00` will be set to 1 on success and 0 on error
INT_STREAMS_CLOSE=11
|: stream file get position
|    * `X00` contains the STREAM/FILE_STREAM-ID
|    * `X01` will be set to the stream position or -1 on error
INT_STREAMS_FILE_GET_POS=12
|: stream file set position
|    * `X00` contains the STREAM/FILE_STREAM-ID
|    * `X01` contains the new position of the stream
|    * `X01` will be set to 1 or 0 on error
|    * note that it is possible to set the stream position behind the end of the file.
|        * when this is done, the next write (not append) operation will fill the hole with zeros
INT_STREAMS_FILE_SET_POS=13
|: stream file add position
|    * `X00` contains the STREAM/FILE_STREAM-ID
|    * `X01` contains the value, which should be added to the position of the stream
|        * `X01` is allowed to be negative, but the sum of the old position and `X01` is not allowed to be negative
|    * `X01` will be set to the new position or -1 on error
|    * note that it is possible to set the stream position behind the end of the file.
|        * when this is done, the next write (not append) operation will fill the hole with zeros
INT_STREAMS_FILE_ADD_POS=14
|: stream file seek eof
|    * `X00` contains the STREAM-ID
|    * `X01` will be set to the new position of the stream or -1 on error
|    * sets the position of the stream to the end of the file (the file length)
INT_STREAMS_FILE_SEEK_EOF=15
|: open element handle file
|    * `X00` points to the `STRING` which contains the path of the file to be opened
|    * `X00` will be set to the newly opened STREAM/FILE-ID or -1 on error
|    * this operation will fail if the element is no file
INT_OPEN_FILE=16
|: open element handle folder
|    * `X00` points to the `STRING` which contains the path of the folder to be opened
|    * `X00` will be set to the newly opened STREAM/FOLDER-ID or -1 on error
|    * this operation will fail if the element is no folder
INT_OPEN_FOLDER=17
|: open element handle pipe
|    * `X00` points to the `STRING` which contains the path of the pipe to be opened
|    * `X00` will be set to the newly opened STREAM/PIPE-ID or -1 on error
|    * this operation will fail if the element is no pipe
INT_OPEN_PIPE=18
|: open element handle (any)
|    * `X00` points to the `STRING` which contains the path of the element to be opened
|    * `X00` will be set to the newly opened STREAM-ID or -1 on error
INT_OPEN_ELEMENT=19
|: element open parent handle
|    * `X00` contains the ELEMENT-ID
|    * `X00` will be set to the newly opened ELEMENT/FOLDER-ID or -1 on error
INT_ELEMENT_OPEN_PARENT=20
|: get create date
|    * `X00` contains the ELEMENT-ID
|    * `X01` will be set to the create date or `-1` on error
|        * note that `-1` may be the create date of the element, so check `ERRNO` instead
INT_ELEMENT_GET_CREATE=21
|: get last mod date
|    * `X00` contains the ELEMENT-ID
|    * `X01` will be set to the last modified date or `-1` on error
|        * note that `-1` may be the last modified date of the element, so check `ERRNO` instead
INT_ELEMENT_GET_LAST_MOD=22
|: set create date
|    * `X00` contains the ELEMENT-ID
|    * `X00` contains the new create date of the element
|    * `X01` will be set to `1` or `0` on error
INT_ELEMENT_SET_CREATE=23
|: set last modified date
|    * `X00` contains the ELEMENT-ID
|    * `X00` contains the last modified date of the element
|    * `X01` will be set to `1` or `0` on error
INT_ELEMENT_SET_LAST_MOD=24
|: element delete
|    * `X00` contains the ELEMENT-ID
|    * note that this operation automatically closes the given ELEMENT-ID, the close interrupt should not be invoked after this interrupt returned
|    * `X01` will be set to `1` or `0` on error
INT_ELEMENT_DELETE=25
|: element move
|    * `X00` contains the ELEMENT-ID
|    * `X01` points to a STRING which will be the new name or it is set to `-1` if the name should not be changed
|    * `X02` contains the ELEMENT-ID of the new parent of `-1` if the new parent should not be changed
|    * when both `X01` and `X02` are set to `-1` this operation will do nothing
|    * `X01` will be set to `1` or `0` on error
INT_ELEMENT_MOVE=26
|: element get name
|    * `X00` contains the ELEMENT-ID
|    * `X01` points the the a memory block, which should be used to store the name as a STRING
|        * when `X01` is set to `-1` a new memory block will be allocated
|    * on success `X01` will point to the name as STRING representation
|        * when the memory block is not large enugh, it will be resized
|        * note that when `X01` does not point to the start of the memory block the start of the memory block can still be moved during the reallocation
|    * on error `X01` will be set to `-1`
INT_ELEMENT_GET_NAME=27
|: element get flags
|    * `X00` contains the ELEMENT-ID
|    * `X01` will be set to the flags or `-1` on error
INT_ELEMENT_GET_FLAGS=28
|: element modify flags
|    * `X00` contains the ELEMENT-ID
|    * `X01` contains the flags to be added
|    * `X02` contains the flags to be removed
|    * note that only the low 32 bit will be used and the high 32 bit will be ignored
|    * `X01` will be set to `1` or `0` on error
INT_ELEMENT_MODIFY_FLAGS=29
|: element folder child count
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X01` will be set to the number of child elements the folder has or `-1` on error
INT_FOLDER_CHILD_COUNT=30
|: folder get child of name
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X00` points to a STRING with the name of the child
|    * `X01` will be set to a newly opened ELEMENT-ID for the child or `-1` on error
INT_FOLDER_OPEN_CHILD_OF_NAME=31
|: folder get child folder of name
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X00` points to a STRING with the name of the child
|    * this operation will fail if the child is no folder
|    * `X01` will be set to a newly opened ELEMENT/FOLDER-ID for the child or `-1` on error
INT_FOLDER_OPEN_CHILD_FOLDER_OF_NAME=32
|: folder get child file of name
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X00` points to a STRING with the name of the child
|    * this operation will fail if the child is no file
|    * `X01` will be set to a newly opened ELEMENT/FILE-ID for the child or `-1` on error
INT_FOLDER_OPEN_CHILD_FILE_OF_NAME=33
|: folder get child pipe of name
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X00` points to a STRING with the name of the child
|    * this operation will fail if the child is no pipe
|    * `X01` will be set to a newly opened ELEMENT/PIPE-ID for the child or `-1` on error
INT_FOLDER_OPEN_CHILD_PIPE_OF_NAME=34
|: folder add child folder
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X00` points to a STRING with the name of the child
|    * `X01` will be set to a newly opened/created ELEMENT/FOLDER-ID for the child or `-1` on error
INT_FOLDER_CREATE_CHILD_FOLDER=35
|: folder add child file
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X01` points to the STRING name of the new child element
|    * `X01` will be set to a newly opened/created ELEMENT/FILE-ID for the child or `-1` on error
INT_FOLDER_CREATE_CHILD_FILE=36 
|: folder add child pipe
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X01` points to the STRING name of the new child element
|    * `X01` will be set to a newly opened/created ELEMENT/PIPE-ID for the child or `-1` on error
INT_FOLDER_CREATE_CHILD_PIPE=37
|: open child iterator of folder
|    * `X00` contains the ELEMENT/FOLDER-ID
|    * `X01` is set to `0` if hidden files should be skipped and any other value if not
|    * `X01` will be set to the FOLDER-ITER-ID or `-1` on error
INT_FOLDER_OPEN_ITER=38
|: get the length of a file
|    * `X00` contains the ELEMENT/FILE-ID
|    * `X01` will be set to the file length in bytes or `-1` on error
INT_FILE_LENGTH=39
|: set the length of a file
|    * `X00` contains the ELEMENT/FILE-ID
|    * `X01` is set to the new length of the file
|    * this interrupt will append zeros to the file when the new length is larger than the old length or remove all content after the new length
|    * `X01` will be set `1` on success or `0` on error
INT_FILE_TRUNCATE=40
|: opens a stream from a file or pipe handle
|    * `X00` contains the ELEMENT/FILE/PIPE-ID
|        * note that this interrupt works for both files and pipes, but will fail for folders
|    * `X01` is set to the open flags
|        * note that the high 32-bit of the flags are ignored
|    * `X01` will be set to the STREAM-ID or `-1` on error
INT_HANDLE_OPEN_STREAM=41
|: get the length of a pipe
|    * `X00` contains the ELEMENT/PIPE-ID
|    * `X01` will be set to the pipe length in bytes or `-1` on error
INT_PIPE_LENGTH=42
|: get the current system time
|    * `X00` will be set to `1` on success and `0` on error
|    * `X01` will be set to the curent system time in seconds since the epoch
|    * `X02` will be set to the additional curent system time in nanoseconds
INT_TIME_GET=43
|: get the system time resolution
|    * `X00` will be set to `1` on success and `0` on error
|    * `X01` will be set to the resolution in seconds
|    * `X02` will be set to the additional resolution in nanoseconds
INT_TIME_RES=44
|: to sleep the given time in nanoseconds
|    * `X00` contain the number of nanoseconds to wait (only values from `0` to `999999999` are allowed)
|    * `X01` contain the number of seconds to wait (only values greather or equal to `0` are allowed)
|    * `X00` and `X01` will contain the remaining time (both `0` if it finished waiting)
|    * `X02` will be `1` if the call was successfully and `0` if something went wrong
|    * `X00` will not be negative if the progress waited too long
INT_TIME_SLEEP=45
|: to wait the given time in nanoseconds
|    * `X00` contain the number of seconds since the epoch
|    * `X01` contain the additional number of nanoseconds
|    * this interrupt will wait until the current system time is equal or after the given absolute time.
|    * `X00` and `X01` will contain the remaining time (both `0` if it finished waiting)
|    * `X02` will be `1` if the call was successfully and `0` if something went wrong
INT_TIME_WAIT=46
|: open a read stream which delivers random values
|    * `X00` will be set to the STREAM-ID or `-1` on error
|        * the stream will only support read operations
|            * not write/append or seek/setpos operations
INT_RND_OPEN=47
|: sets `X00` to a random number
|    * `X00` will be set to a random non negative number or `-1` on error
INT_RND_NUM=48
|: memory copy
|    * copies a block of memory
|    * this function has undefined behavior if the two blocks overlap
|    * `X00` points to the target memory block
|    * `X01` points to the source memory block
|    * `X02` has the length of bytes to bee copied
INT_MEM_CPY=49
|: memory move
|    * copies a block of memory
|    * this function makes sure, that the original values of the source block are copied to the target block (even if the two block overlap)
|    * `X00` points to the target memory block
|    * `X01` points to the source memory block
|    * `X02` has the length of bytes to bee copied
INT_MEM_MOV=50
|: memory byte set
|    * sets a memory block to the given byte-value
|    * `X00` points to the block
|    * `X01` the first byte contains the value to be written to each byte
|    * `X02` contains the length in bytes
INT_MEM_BSET=51
|: string length
|    * `X00` points to the STRING
|    * `X00` will be set to the length of the string/ the (byte-)offset of the first byte from the `'\0'` character
INT_STR_LEN=52
|: string compare
|    * `X00` points to the first STRING
|    * `X01` points to the second STRING
|    * `X00` will be set to zero if both are equal STRINGs, a value greather zero if the first is greather and below zero if the second is greather
|        * a STRING is greather if the first missmatching char has numeric greather value
INT_STR_CMP=53
|: number to string
|    * `X00` is set to the number to convert
|    * `X01` is points to the buffer to be filled with the number in a STRING format
|    * `X02` contains the base of the number system
|        * the minimum base is `2`
|        * the maximum base is `36`
|    * `X03` is set to the length of the buffer
|        * `0` when the buffer should be allocated by this interrupt
|    * `X00` will be set to the size of the STRING (without the `\0` terminating character)
|    * `X01` will be set to the new buffer
|    * `X03` will be set to the new size of the buffer
|        * the new length will be the old length or if the old length is smaller than the size of the STRING (with `\0`) than the size of the STRING (with `\0`)
|    * on error `X01` will be set to `-1`
INT_STR_FROM_NUM=54
|: floating point number to string
|    * `X00` is set to the floating point number to convert
|    * `X01` points to the buffer to be filled with the number in a STRING format
|    * `X02` is set to the current size of the buffer
|        * `0` when the buffer should be allocated by this interrupt
|    * `X00` will be set to the size of the STRING
|    * `X01` will be set to the new buffer
|    * `X02` will be set to the new size of the buffer
|        * the new length will be the old length or if the old length is smaller than the size of the STRING (with `\0`) than the size of the STRING (with `\0`)
|    * on error `X01` will be set to `-1`
INT_STR_FROM_FPNUM=55
|: string to number
|    * `X00` points to the STRING
|    * `X01` points to the base of the number system
|        * (for example `10` for the decimal system or `2` for the binary system)
|        * the minimum base is `2`
|        * the maximum base is `36`
|    * `X00` will be set to the converted number
|    * on success `X01` will be set to `1`
|    * on error `X01` will be set to `0`
|        * the STRING contains illegal characters
|        * or the base is not valid
|        * if `ERRNO` is set to out of range, the string value displayed a value outside of the 64-bit number range and `X00` will either be min or max value
INT_STR_TO_NUM=56
|: string to floating point number
|    * `X00` points to the STRING
|    * `X00` will be set to the converted number
|    * on success `X01` will be set to `1`
|    * on error `X01` will be set to `0`
|        * the STRING contains illegal characters
|        * or the base is not valid
INT_STR_TO_FPNUM=57
|: STRING to U16-STRING
|    * `X00` points to the STRING (`UTF-8`)
|    * `X01` points to the buffer to be filled with the to `UTF-16` converted string
|    * `X02` is set to the length of the buffer
|    * `X00` points to the start of the unconverted sequenze (or behind the `\0` terminator)
|    * `X01` points to the start of the unmodified space of the target buffer
|    * `X02` will be set to unmodified space at the end of the buffer
|    * `X03` will be set to the number of converted characters or `-1` on error
INT_STR_TO_U16STR=58
|: STRING to U32-STRING
|    * `X00` points to the STRING (`UTF-8`)
|    * `X01` points to the buffer to be filled with the to `UTF-32` converted string
|    * `X02` is set to the length of the buffer
|    * `X00` points to the start of the unconverted sequenze (or behind the `\0` terminator)
|    * `X01` points to the start of the unmodified space of the target buffer
|    * `X02` will be set to unmodified space at the end of the buffer
|    * `X03` will be set to the number of converted characters or `-1` on error
INT_STR_TO_U32STR=59
|: U16-STRING to STRING
|    * `X00` points to the `UTF-16` STRING
|    * `X01` points to the buffer to be filled with the converted STRING (`UTF-8`)
|    * `X02` is set to the length of the buffer
|    * `X00` points to the start of the unconverted sequenze (or behind the `\0` terminator (note that the `\0` char needs two bytes))
|    * `X01` points to the start of the unmodified space of the target buffer
|    * `X02` will be set to unmodified space at the end of the buffer
|    * `X03` will be set to the number of converted characters or `-1` on error
INT_STR_FROM_U16STR=60
|: U32-STRING to STRING
|    * `X00` points to the `UTF-32` STRING
|    * `X01` points to the buffer to be filled with the converted STRING (`UTF-8`)
|    * `X02` is set to the length of the buffer
|    * `X00` points to the start of the unconverted sequenze (or behind the `\0` terminator (note that the `\0` char needs four bytes))
|    * `X01` points to the start of the unmodified space of the target buffer
|    * `X02` will be set to unmodified space at the end of the buffer
|    * `X03` will be set to the number of converted characters or `-1` on error
INT_STR_FROM_U32STR=61
|: format string
|    * `X00` is set to the STRING input
|    * `X01` contains the buffer for the STRING output
|    * `X02` is the size of the buffer in bytes
|    * the register `X03` points to the formatting arguments
|    * `X00` will be set to the length of the output string (the offset of the `\0` character) or `-1` on error
|        * if `X00` is larger or equal to `X02`, only the first `X02` bytes will be written to the buffer
|    * formatting:
|        * `%%`: to escape an `%` character (only one `%` will be in the formatted STRING)
|        * `%s`: the next argument points to a STRING, which should be inserted here
|        * `%c`: the next argument starts with a byte, which should be inserted here
|            * note that UTF-8 characters are not always represented by one byte, but there will always be only one byte used
|        * `%n`: consumes two arguments
|            1. the next argument contains a number in the range of `2..36`.
|                * if the first argument is less than `2` or larger than `36` the interrupt will fail
|            2. which should be converted to a STRING using the number system with the basoe of the first argument and than be inserted here
|        * `%d`: the next argument contains a number, which should be converted to a STRING using the decimal number system and than be inserted here
|        * `%f`: the next argument contains a floating point number, which should be converted to a STRING and than be inserted here
|        * `%p`: the next argument contains a pointer, which should be converted to a STRING
|            * if the pointer is not `-1` the pointer will be converted by placing a `"p-"` and then the unsigned pointer-number converted to a STRING using the hexadecimal number system
|            * if the pointer is `-1` it will be converted to the STRING `"p-inval"`
|        * `%h`: the next argument contains a number, which should be converted to a STRING using the hexadecimal number system and than be inserted here
|        * `%b`: the next argument contains a number, which should be converted to a STRING using the binary number system and than be inserted here
|        * `%o`: the next argument contains a number, which should be converted to a STRING using the octal number system and than be inserted here
INT_STR_FORMAT=62
|: load a file
|    * `X00` is set to the path (inclusive name) of the file
|    * `X00` will point to the memory block, in which the file has been loaded or `-1` on error
|    * `X01` will be set to the length of the file (and the memory block)
INT_LOAD_FILE=63
|: load a library file 
|    * similar like the load file interrupt loads a file for the program.
|        * the difference is that this interrupt may remember which files has been loaded
|            * there are no guarantees, when the same memory block is reused and when a new memory block is created
|        * the other difference is that the file may only be unloaded with the unload lib interrupt (not with the free interrupt)
|            * the returned memory block also can not be resized
|        * if the interrupt is executed multiple times with the same file, it will return every time the same memory block.
|        * this interrupt does not recognize files loaded with the `64` (`INT_LOAD_FILE`) interrupt.
|    * `X00` is set to the path (inclusive name) of the file
|    * `X00` will point to the memory block, in which the file has been loaded
|    * `X01` will be set to the length of the file (and the memory block)
|    * `X02` will be set to `1` if the file has been loaded as result of this interrupt and `0` if the file was previously loaded
|    * when an error occurred `X00` will be set to `-1`
INT_LOAD_LIB=64
|: unload a library file 
|    * unloads a library previously loaded with the load lib interrupt
|    * this interrupt will ensure that the given memory block will be freed and never again be returned from the load lib interrupt
|    * `X00` points to the (start of the) memory block
INT_UNLOAD_LIB=65
|: the initial value of the `INTCNT` register
| this constant holds the number of default interrupts
INTERRUPT_COUNT=76
|: NaN
| the floating point constant holding a nan value
FP_NAN=UHEX-7FFE000000000000
|: floating point max
FP_MAX_VALUE=UHEX-7FEFFFFFFFFFFFFF
|: floating point min
FP_MIN_VALUE=UHEX-0000000000000001
|: floating point constant for positive infinity
FP_POS_INFINITY=UHEX-7FF0000000000000
|: floating point constant for positive infinity
FP_NEG_INFINITY=UHEX-FFF0000000000000
|: the first memory address of the register memory block
| note that X00 is not the first register, but IP
REGISTER_MEMORY_START=HEX-0000000000001000
|: the first memory address of the XNN registers
REGISTER_MEMORY_START_XNN=HEX-0000000000001028
|: the address which refers to the last register of the PVM
REGISTER_MEMORY_LAST_ADDRESS=HEX-00000000000017F8
|: the lowest byte address which is above the PVM register memory block
REGISTER_MEMORY_END_ADDRESS_SPACE=HEX-0000000000001800
|: the maximum number value
MAX_VALUE=HEX-7FFFFFFFFFFFFFFF
|: the minimum number value
MIN_VALUE=NHEX-8000000000000000
|: the STREAM-ID of the stdin pipe stream
| this stream is initially open for reading
STD_IN=0
|: the STREAM-ID of the stdout pipe stream
| this stream is initially open for writing
STD_OUT=1
|: the STREAM-ID of the stdlog pipe stream
| this stream is initially open for writing
STD_LOG=2
|:  if pfs_errno is not set/no error occurred 
ERR_NONE=0
|:  if an operation failed because of an unknown/unspecified error 
ERR_UNKNOWN_ERROR=1
|:  if the iterator has no next element 
ERR_NO_MORE_ELEMNETS=2
|:  if an IO operation failed because the element is not of the correct type (file expected, but folder or reverse) 
ERR_ELEMENT_WRONG_TYPE=3
|:  if an IO operation failed because the element does not exist 
ERR_ELEMENT_NOT_EXIST=4
|:  if an IO operation failed because the element already existed 
ERR_ELEMENT_ALREADY_EXIST=5
|:  if an IO operation failed because there was not enough space in the file system 
ERR_OUT_OF_SPACE=6
|:  if an unspecified IO error occurred 
ERR_IO_ERR=7
|:  if there was at least one invalid argument 
ERR_ILLEGAL_ARG=8
|:  if there was an invalid magic value 
ERR_ILLEGAL_MAGIC=9
|:  if an IO operation failed because there was not enough space in the file system 
ERR_OUT_OF_MEMORY=10
|:  if an IO operation failed because the root folder has some restrictions 
ERR_ROOT_FOLDER=11
|:  if an folder can not be moved because the new child (maybe a deep/indirect child) is a child of the folder 
ERR_PARENT_IS_CHILD=12
|:  if an element which is opened elsewhere is tried to be deleted 
ERR_ELEMENT_USED=13
|:  if some value was outside of the allowed range 
ERR_OUT_OF_RANGE=14
|: the unmodifiable flags
| these flags can only be changed on creation
UNMODIFIABLE_FLAGS=UHEX-000000FF
|: the pipe flag
| this flag can only be changed on creation
FLAG_FOLDER=UHEX-00000001
|: the file flag
| this flag can only be changed on creation
FLAG_FILE=UHEX-00000002
|: the pipe flag
| this flag can only be changed on creation
FLAG_PIPE=UHEX-00000004
|: the executable flag
FLAG_EXECUTABLE=UHEX-00000100
|: the hidden flag
FLAG_HIDDEN=UHEX-01000000
|: create the file/pipe
| fail if the file/pipe exist already
STREAM_ONLY_CREATE=UHEX-00000001
|: create the file/pipe if it does not exist
| do not fail if the file/pipe exist already (overwritten by PFS_SO_ONLY_CREATE)
STREAM_ALSO_CREATE=UHEX-00000002
|: a file stream
| fail if the element is a pipe and if CREATE is set create a file
STREAM_FILE=UHEX-00000004
|: a pipe stream
| fail if the element is a file and if CREATE is set create a pipe
STREAM_PIPE=UHEX-00000008
|: open the stream for read access
STREAM_READ=UHEX-00000100
|: open the stream for write access
STREAM_WRITE=UHEX-00000200
|: open the stream for append access
| (before every write operation the position is set to the end of the file)
STREAM_APPEND=UHEX-00000400
|: truncate the files content
STREAM_FILE_TRUNC=UHEX-00010000
|: set the position initially to the end of the file not the start
STREAM_FILE_EOF=UHEX-00020000
