|   * `0`: illegal interrupt
|       * `X00` contains the number of the illegal interrupt
|       * calls the exit interrupt with `(64 + illegal_interrup_number)`
|       * if the forbidden interrupt is the exit input, the program exits with `(64 + 4) = 68`, but does not calls the exit interrupt to do so
|       * if this interrupt is tried to bee called, but it is forbidden to call this interrupt, the program exits with `63`
INT_ERRORS_ILLEGAL_INTERRUPT=0
|   * `1`: unknown command
|       * calls the exit interrupt with `62`
INT_ERRORS_UNKNOWN_COMMAND=1
|   * `2`: illegal memory
|       * calls the exit interrupt with `61`
INT_ERRORS_ILLEGAL_MEMORY=2
|   * `3`: arithmetic error
|       * calls the exit interrupt with `60`
INT_ERRORS_ARITHMETIC_ERROR=3
|   * `4`: exit
|       * use `X00` to specify the exit number of the progress
INT_EXIT=4
|   * `5`: allocate a memory-block
|       * `X00` saves the size of the block
|       * if the value of `X00` is `-1` after the call the memory-block could not be allocated
|       * if the value of `X00` is not `-1`, `X00` points to the first element of the allocated memory-block
INT_MEMORY_ALLOC=5
|   * `6`: reallocate a memory-block
|       * `X00` points to the memory-block
|       * `X01` is set to the new size of the memory-block
|       * `X01` will be `-1` if the memory-block could not be reallocated, the old memory-block will remain valid and should be freed if it is not longer needed
|       * `X01` will point to the new memory block, the old memory-block was automatically freed, so it should not be used, the new block should be freed if it is not longer needed
INT_MEMORY_REALLOC=6
|   * `7`: free a memory-block
|       * `X00` points to the old memory-block
|       * after this the memory-block should not be used
INT_MEMORY_FREE=7
|   * `8`: open new stream
|       * `X00` contains a pointer to the STRING, which refers to the file which should be read
|       * `X01` specifies the open mode: (bitwise flags)
|           * `UHEX-0000000000000001` : `OPEN_READ` open file for read access
|           * `UHEX-0000000000000002` : `OPEN_WRITE` open file for write access
|           * `UHEX-0000000000000004` : `OPEN_APPEND` open file for append access (implicit set of `OPEN_WRITE`)
|           * `UHEX-0000000000000008` : `OPEN_CREATE` open file or create file (needs `OPEN_WRITE`, not compatible with `OPEN_NEW_FILE`)
|           * `UHEX-0000000000000010` : `OPEN_NEW_FILE` fail if file already exists or create the file (needs `OPEN_WRITE`, not compatible with `OPEN_CREATE`)
|           * `UHEX-0000000000000020` : `OPEN_TRUNCATE` if the file already exists, remove its content (needs `OPEN_WRITE`)
|           * other flags will be ignored
|           * the operation will fail if it is not specified if the file should be opened for read, write and/or append
|       * opens a new stream to the specified file
|       * if successfully the STREAM-ID will be saved in the `X00` register
|       * if failed `X00` will contain `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000` : `STATUS_ELEMENT_WRONG_TYPE`: operation failed because the element is not of the correct type (file expected, but folder)
|                   * if the element already exists, but is a folder and no file
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|                   * if the element does not exists, but `OPEN_CREATE` and `OPEN_NEW_FILE` are not set
|               * `UHEX-0100000000000000` : `STATUS_ELEMENT_ALREADY_EXIST`: operation failed because the element already existed
|                   * if the element already exists, but `OPEN_NEW_FILE` is set
|               * `UHEX-0200000000000000` : `STATUS_OUT_OF_SPACE`: operation failed because there was not enough space in the file system
|                   * if the system tried to create the new file, but there was not enough space for the new file-system-entry
|               * `UHEX-0400000000000000` : `STATUS_READ_ONLY`: was denied because of read-only
|                   * if the file is marked as read-only, but it was tried to open the file for read or append access
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the file is locked with `LOCK_NO_READ_ALLOWED` : `UHEX-0000000100000000` and it was tried to open the file for read access
|                   * or if the file is locked with `LOCK_NO_WRITE_ALLOWED_LOCK` : `UHEX-0000000200000000` and it was tried to open the file for write/append access
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: STREAM-ID is invalid or `X01` contains an invalid open mode
|                   * if the open mode was invalid
|                       * `OPEN_CREATE` with `OPEN_NEW_FILE`
|                       * not `OPEN_READ` and not `OPEN_WRITE` and not `OPEN_APPEND`
|                       * `OPEN_CREATE`, `OPEN_NEW_FILE` and/or `OPEN_TRUNCATE` without `OPEN_WRITE` (and without `OPEN_APPEND`)
|       * to close the stream call the free interrupt (`7` : `INT_MEMORY_FREE`)
INT_STREAMS_NEW=8
|   * `9`: write
|       * `X00` contains the STREAM-ID
|       * `X01` contains the number of elements to write
|       * `X02` points to the elements to write
|       * after execution `X01` will contain the number of written elements or `-1` if an error occurred
|       * if an error occurred the `STATUS` register will be flagged:
|           * `UHEX-0200000000000000` : `STATUS_OUT_OF_SPACE`: operation failed because there was not enough space in the file system
|               * if the system tried to allocate more space for either the file-system-entry of the open file or its content, but there was not enough space
|           * `UHEX-0400000000000000` : `STATUS_READ_ONLY`: was denied because of read-only
|               * if the file is marked as read-only
|           * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|               * if the file is locked with `LOCK_NO_WRITE_ALLOWED_LOCK` : `UHEX-0000000200000000`
|           * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|               * if some IO error occurred
|           * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: STREAM-ID is invalid or `X01` is negative
|               * if the STREAM-ID is invalid (maybe because the corresponding file was deleted)
|               * or if a negative number of bytes should be written
INT_STREAMS_WRITE=9
|   * `10`: read
|       * `X00` contains the STREAM-ID
|       * `X01` contains the number of elements to read
|       * `X02` points to the elements to read
|       * after execution `X01` will contain the number of elements, which has been read
|       * if an error occured `X01` will be set to `-1` and the `STATUS` register will be flagged:
|           * `UHEX-0040000000000000` : `STATUS_ELEMENT_WRONG_TYPE`: operation failed because the element is not of the correct type (file expected, but folder)
|               * if the element was re-reated as folder (the re-created folder may has a different path and/or name)
|           * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|               * if the element was deleted
|           * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|               * if the file is locked with `LOCK_NO_READ_ALLOWED` : `UHEX-0000000100000000`
|           * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|               * if some IO error occurred
|           * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: STREAM-ID is invalid or `X01` is negative
|               * if the STREAM-ID is invalid (maybe because the corresponding file was deleted)
|               * or if a negative number of bytes should be written
|       * if `X01` is `0` and was set before to a value greater `0` then the stream has reached its end
|       * reading less bytes than expected does not mead that the stream has reached it's end
INT_STREAMS_READ=10
|   * `11`: get fs-file
|       * `X00` contains a pointer of a STRING with the file
|       * `X00` will point to a fs-element of the file
|       * on failure `X00` will be set to `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000` : `STATUS_ELEMENT_WRONG_TYPE`: operation failed because the element is not of the correct type (file expected, but folder)
|                   * if the element exists, but is a folder and no file
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|                   * if the element does not exists
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-4000000000000000` : `STATUS_OUT_OF_MEMORY`: not enough memory could be allocated
|                   * the system could not allocate enough memory for the fs-element
|       * if the specified element is a link to a file, the target file of the link is returned instead of the actual link
INT_FS_GET_FILE=11
|   * `12`: get fs-folder
|       * `X00` contains a pointer of a STRING with the dictionary
|       * `X00` will point to a fs-element of the folder
|       * on failure `X00` will be set to `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000` : `STATUS_ELEMENT_WRONG_TYPE`: operation failed because the element is not of the correct type (folder expected, but file)
|                   * if the element exists, but is a file and no folder
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|                   * if the element does not exists
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-4000000000000000` : `STATUS_OUT_OF_MEMORY`: not enough memory could be allocated
|                   * the system could not allocate enough memory for the fs-element
|       * if the specified element is a link to a folder, the target folder of the link is returned instead of the actual link
INT_FS_GET_FOLDER=12
|   * `13`: get fs-link
|       * `X00` contains a pointer of a STRING with the link
|       * `X00` will point to a fs-element of the link
|       * on failure `X00` will be set to `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000` : `STATUS_ELEMENT_WRONG_TYPE`: operation failed because the element is not of the correct type (link expected, but file or folder)
|                   * if the element exists, but is a file and no folder
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|                   * if the element does not exists
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-4000000000000000` : `STATUS_OUT_OF_MEMORY`: not enough memory could be allocated
|                   * the system could not allocate enough memory for the fs-element
INT_FS_GET_LINK=13
|   * `14`: get fs-element
|       * `X00` contains a pointer of a STRING with the element
|       * `X00` will point to the fs-element
|       * on failure `X00` will be set to `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|                   * if the element does not exists
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID  of the fs-element is invalid (because it was deleted)
|               * `UHEX-4000000000000000` : `STATUS_OUT_OF_MEMORY`: not enough memory could be allocated
|                   * the system could not allocate enough memory for the fs-element
|       * if the specified element is a link the actual link is returned
INT_FS_GET_ELEMENT=14
|   * `15`: duplicate fs-element (handle)
|       * `X00` points to the fs-element
|       * `X00` will point to a duplicate of the same element
|       * if the system could not allocate enough memory for the duplicate `X00` will be set to `-1`
INT_FS_DUPLICATE_HANDLE=15
|   * `16`: get parent
|       * `X00` points to the fs-element
|       * `[X00]` : `[X00 + FS_ELEMENT_OFFSET_ID]` will be set to the ID of the parent folder
|           + note that the only negative ID is `-2` (root folder)
|           * all other IDs are `0` or positive, but not all positive numbers are valid IDs
|       * on failure `X00` will be set to `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|                   * if the element does not exists
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` is a fs-element of the root folder or contains itself an invalid ID
|                   * if the given fs-element is the root folder
|                   * or if the given ID  of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_GET_PARENT=16
|   * `17`: fs-element from ID
|       * `X00` is set to the ID of the element
|       * `X00` will be set to a fs-element of the element with the given id
|       * on failure `X00` will be set to `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: operation failed because the element does not exist
|                   * if the element does not exists
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` is invalid ID
|                   * if the given ID is invalid
|                       * all negative IDs except of `-2` are invalid (the root folder has the ID `-2`)
INT_FS_ELEMENT_FROM_ID=17
|   * `18`: get create date
|       * `X00` points to the fs-element
|       * `X01` will be set to the create time of the element
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_GET_CREATE=18
|   * `19`: get last mod date
|       * `X00` points to the fs-element
|       * `X01` will be set to the last modify time of the element
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_GET_LAST_MOD=19
|   * `20`: get last meta mod date
|       * `X00` points to the fs-element
|       * `X01` will be set to the last meta mod time of the element
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_GET_LAST_META_MOD=20
|   * `21`: set create date
|       * `X00` points to the fs-element
|       * `X01` contains the new create date
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0400000000000000` : `STATUS_READ_ONLY`: operation was denied because of read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with `LOCK_NO_META_CHANGE_ALLOWED_LOCK` : `UHEX-0000000800000000`
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_SET_CREATE=21
|   * `22`: set last mod date
|       * `X00` points to the fs-element
|       * `X01` contains the new last mod date
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0400000000000000` : `STATUS_READ_ONLY`: operation was denied because of read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with `LOCK_NO_META_CHANGE_ALLOWED_LOCK` : `UHEX-0000000800000000`
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_SET_LAST_MOD=22
|   * `23`: set last meta mod date
|       * `X00` points to the fs-element
|       * `X01` contains the new last meta mod date
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0400000000000000` : `STATUS_READ_ONLY`: operation was denied because of read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with `LOCK_NO_META_CHANGE_ALLOWED_LOCK` : `UHEX-0000000800000000`
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|       * note: when changing all dates change this date at last, because it will bee automatically changed on meta changes like the change of the create or last mod date
INT_FS_ELEMENT_SET_LAST_META_MOD=23
|   * `24`: get lock data
|       * `X00` points to the fs-element
|       * `X00` will be set to the lock data of the element
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_GET_LOCK_DATA=24
|   * `25`: get lock date
|       * `X00` points to the fs-element
|       * `X01` will be set to the lock date of the element or `-1` if the element is not locked
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_GET_LOCK_TIME=25
|   * `26`: lock element
|       * `X00` points to the fs-element
|       * `X01` is set to the lock data of the new lock
|       * `[X00 + 8]` : `[X00 + FS_ELEMENT_OFFSET_LOCK]` will be set to the new lock
|       * if the element is already exclusively locked the operation will fail
|       * if the element is locked with a shared lock and the lock data of the given lock is the same to the lock data of the current lock:
|           * a shared lock is flagged with `UHEX-4000000000000000` : `LOCK_SHARED_LOCK`
|           * the new lock will not contain the shared lock counter
|           * the lock should be released like a exclusive lock, when it is no longer needed
|           * a shared lock does not give you any permissions, it just blocks operations for all (also for those with the lock)
|       * if the given lock is not flagged with `UHEX-8000000000000000` : `LOCK_LOCKED_LOCK`, it will be automatically be flagged with `UHEX-8000000000000000`: `LOCK_LOCKED_LOCK`
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is already locked
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or `X01` not only lock data bits
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|                   * or if the given lock does not only specify the lock data
INT_FS_ELEMENT_LOCK=26
|   * `27`: unlock element
|       * `X00` points to the fs-element
|       * `[X00 + 8]` : `[X00 + FS_ELEMENT_OFFSET_LOCK]` will be set to `UHEX-0000000000000000` : `LOCK_NO_LOCK`
|       * if the element is not locked with the given lock the operation will fail
|           * if the given lock is `UHEX-0000000000000000` : `LOCK_NO_LOCK`, the operation will always try to remove the lock of the element
|       * if the element is locked with a shared lock:
|           * if this is the last lock, the shared lock will be removed
|           * else the shared lock counter will be decremented
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_UNLOCK=27
|   * `28`: delete element
|       * `X00` points to the fs-element
|       * `X01` contains the lock of the parent element or `UHEX-0000000000000000` : `LOCK_NO_LOCK`
|       * deletes the element from the file system
|       * releases also the fs-element
|           * to release a fs-element (handle) normally just use the free interrupt (`7` : `INT_MEMORY_FREE`)
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0200000000000000` : `STATUS_OUT_OF_SPACE`: operation failed because the there could not be allocated enough space
|                   * the file system was not able to resize the file system entry to a smaller size
|                       * the block intern table sometimes grow when a area is released
|                       * if the block intern table can not grow this error will occur
|               * `UHEX-0400000000000000` : `STATUS_READ_ONLY`: operation was denied because of read-only
|                   * if the element or its parent is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element or its parent is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_ELEMENT_DELETE=28
|   * `29`: move element
|       * `X00` points to the fs-element
|       * `X01` points to the new parent fs-element folder
|           * or `-1` if the parent folder should remain unchanged
|       * `X02` points to the STRING name of the element
|           * or `-1` if the name should remain unchanged
|       * `X03` contains the lock of the old parent folder or `UHEX-0000000000000000` : `LOCK_NO_LOCK`
|           * this value is ignored if `X01` is set to `-1` (the parent folder is not set)
|       * moves the element to a new parent folder and sets its name
|           * note that both operations (set parent folder and set name) are optional
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0400000000000000` : `STATUS_READ_ONLY`: operation was denied because of read-only
|                   * if the element, its (old) parent or its (not) new parent is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element, its (old) parent or its (not) new parent is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
INT_FS_ELEMENT_MOVE=29
|   * `30`: get element flags
|       * `X00` points to the fs-element
|       * `X01` will be set to the flags of the element
|       * `X01` will be set to `0` if an error occurred
|           * the `STATUS` register will be flagged:
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|       * note that links are also flagged as folder or file
|           * if the link target element is a file, the link is also flagged as file
|           * if the link target element is a folder, the link is also flagged as folder
|           * a link to a link is invalid
INT_FS_ELEMENT_GET_FLAGS=30
|   * `31`: modify element flags
|       * `X00` points to the fs-element
|       * `X01` contains the flags to add to the element
|       * `X02` contains the flags to remove from the element
|       * note that the flags wich specify if the element is a folder, file or link are not allowed to be set/removed
|       * on error `X01` will be set to `-1`
|           * the `STATUS` register will be flagged:
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or invalid flag modify
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|                   * or if the flags to add or to remove contain the bits:
|                       * `HEX-00000001` : `FLAG_FOLDER`
|                       * `HEX-00000002``: `FLAG_FILE`
|                       * `HEX-00000004` : `FLAG_LINK`
|       * bits out of the 32-bit range will be ignored
|           * the 32-bit with less value are used (`UHEX-00000000FFFFFFFF`)
INT_FS_ELEMENT_MOD_FLAGS=31
|   * `31`: get folder child element count
|       * `X00` points to the fs-element folder
|       * `X01` will be set to the child element count of the given folder
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_FOLDER_CHILD_COUNT=32
|   * `33`: get child element from index
|       * `X00` points to the fs-element folder
|       * `X01` contains the index of the child element
|       * `[X00]` : `[X00 + FS_ELEMENT_OFFSET_ID]` will be set to the id of the child element
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no folder
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|                   * or if the index is out of range (negative or greater or equal to the child element count of the given folder)
INT_FS_FOLDER_GET_CHILD_OF_INDEX=33
|   * `34`: get child element from name
|       * `X00` points to the fs-element folder
|       * `X01` points to the STRING name of the child element
|       * `[X00]` : `[X00 + FS_ELEMENT_OFFSET_ID]` will be set to the id of the child element
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no folder
|               * `UHEX-0080000000000000` : `STATUS_ELEMENT_NOT_EXIST`: the folder does not contain a child with the given name
|                   * if there is no child with the given name
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_FOLDER_GET_CHILD_OF_NAME=34
|   * `35`: add folder
|       * `X00` points to the fs-element folder
|       * `X01` points to the STRING name of the new child element
|       * `[X00]` : `[X00 + FS_ELEMENT_OFFSET_ID]` will be set to the id of the new child element folder
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no folder
|               * `UHEX-0100000000000000` : `STATUS_ELEMENT_ALREADY_EXIST`: the folder already contain a child with the given name
|                   * if there is already child with the given name
|               * `UHEX-0400000000000000` : `STATUS_ELEMENT_READ_ONLY`: operation was denied because read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|       * the folder will automatically removed the sorted flag (`HEX-00000040` : `FLAG_FOLDER_SORTED`)
INT_FS_FOLDER_ADD_FOLDER=35
|   * `36`: add file
|       * `X00` points to the fs-element folder
|       * `X01` points to the STRING name of the new child element
|       * `[X00]` : `[X00 + FS_ELEMENT_OFFSET_ID]` will be set to the id of the new child element file
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no folder
|               * `UHEX-0100000000000000` : `STATUS_ELEMENT_ALREADY_EXIST`: the folder already contain a child with the given name
|                   * if there is already child with the given name
|               * `UHEX-0400000000000000` : `STATUS_ELEMENT_READ_ONLY`: operation was denied because read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|       * the folder will automatically remove the sorted flag (`HEX-00000040` : `FLAG_FOLDER_SORTED`)
INT_FS_FOLDER_ADD_FILE=36
|   * `37`: add link
|       * `X00` points to the fs-element folder
|       * `X01` points to the STRING name of the new child element
|       * `X02` points to the fs-element of the target element
|           * the target element is not allowed to be a link
|       * `[X00]` : `[X00 + FS_ELEMENT_OFFSET_ID]` will be set to the id of the new child element link
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no folder
|               * `UHEX-0100000000000000` : `STATUS_ELEMENT_ALREADY_EXIST`: the folder already contain a child with the given name
|                   * if there is already child with the given name
|               * `UHEX-0400000000000000` : `STATUS_ELEMENT_READ_ONLY`: operation was denied because read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|       * the folder will automatically remove the sorted flag (`HEX-00000040` : `FLAG_FOLDER_SORTED`)
INT_FS_FOLDER_ADD_LINK=37
|   * `38`: file length
|       * `X00` points to the fs-element file
|       * `X01` will be set to the length of the file in bytes
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no file
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_FILE_LENGTH=38
|   * `39`: file hash
|       * `X00` points to the fs-element file
|       * `X01` points to a at least 256-byte large memory block
|           * the memory block from `X01` will be filled with the SHA-256 hash code of the file
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no file
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_FILE_HASH=39
|   * `40`: file read
|       * `X00` points to the fs-element file
|       * `X01` contains the offset from the file
|       * `X02` contains the number of bytes to read
|       * `X03` points to a memory block to which the file data should be filled
|       * `X02` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no file
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or the offset / read count is invalid
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|                   * or if the read count or file offset is negative
|                   * or if the read count + file offset is larger than the file length
INT_FS_FILE_READ=40
|   * `41`: file write
|       * `X00` points to the fs-element file
|       * `X01` contains the offset from the file
|       * `X02` contains the number of bytes to write
|       * `X03` points to the memory block with the data to write
|       * `X02` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no file
|               * `UHEX-0400000000000000` : `STATUS_ELEMENT_READ_ONLY`: operation was denied because read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or the offset / read count is invalid
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|                   * or if the write count or file offset is negative
|                   * or if the write count + file offset is larger than the file length
INT_FS_FILE_WRITE=41
|   * `42`: file append
|       * `X00` points to the fs-element file
|       * `X01` contains the number of bytes to append
|       * `X02` points to the memory block with the data to write
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no file
|               * `UHEX-0200000000000000` : `STATUS_OUT_OF_SPACE`: operation failed because the there could not be allocated enough space for the larger file
|                   * the file system could either not allocate enough blocks for the new larger file
|                   * or the file system could not allocate enough space for the larger file system entry of the file
|               * `UHEX-0400000000000000` : `STATUS_ELEMENT_READ_ONLY`: operation was denied because read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or the offset / read count is invalid
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|                   * or if the write count or file offset is negative
|                   * or if the write count + file offset is larger than the file length
INT_FS_FILE_APPEND=42
|   * `43`: file truncate
|       * `X00` points to the fs-element file
|       * `X01` contains the new length of the file
|       * removes all data from the file which is behind the new length
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no file
|               * `UHEX-0200000000000000` : `STATUS_OUT_OF_SPACE`: operation failed because the there could not be allocated enough space
|                   * the file system was not able to resize the file system entry to a smaller size
|                       * the block intern table sometimes grow when a area is released
|                       * if the block intern table can not grow this error can occur
|               * `UHEX-0400000000000000` : `STATUS_ELEMENT_READ_ONLY`: operation was denied because read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or the offset / read count is invalid
|                   * if the given ID of the fs-element is invalid (because it was deleted)
|                   * or if the new length is larger than the current file length
|                   * or if the new length is negative
INT_FS_FILE_TRUNCATE=43
|   * `44`: link get target
|       * `X00` points to the fs-element link
|       * `[X00]` : `[X00 + FS_ELEMENT_OFFSET_ID]` will be set to the target ID
|       * `X01` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no link
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or the offset / read count is invalid
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_LINK_GET_TARGET=44
|   * `45`: link set target
|       * `X00` points to the fs-element link
|       * `X01` points to the new target element
|       * sets the target element of the link
|           * also flags the link with file or folder and removes the other flag (`HEX-00000001` : `FLAG_FOLDER` or `HEX-00000002` : `FLAG_FILE`)
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0040000000000000`: `STATUS_ELEMENT_WRONG_TYPE`: the given element is of the wrong type
|                   * if the given element is no link
|               * `UHEX-0400000000000000` : `STATUS_ELEMENT_READ_ONLY`: operation was denied because read-only
|                   * if the element is marked as read-only
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the element is locked with a different lock
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` contains an invalid ID or the offset / read count is invalid
|                   * if the given ID of the fs-element is invalid (because it was deleted)
INT_FS_LINK_SET_TARGET=45
|   * `46`: lock file-system
|       * `X00` contains the new lock data
|       * the lock is like a lock for elements, but it works for all elements
|       * if the file system is already exclusively locked the operation will fail
|       * if the file system is locked with a shared lock and the lock data of the given lock is the same to the lock data of the current lock:
|           * a shared lock is flagged with `UHEX-4000000000000000` : `LOCK_SHARED_LOCK`
|           * the new lock will not contain the shared lock counter
|           * the lock should be released like a exclusive lock, when it is no longer needed
|           * a shared lock does not give you any permissions, it just blocks operations for all (also for those with the lock)
|       * if the given lock is not flagged with `UHEX-8000000000000000` : `LOCK_LOCKED_LOCK`, it will be automatically be flagged with `UHEX-8000000000000000`: `LOCK_LOCKED_LOCK`
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the file system, is already locked
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified io error occurred
|                   * if some IO error occurred
|               * `UHEX-2000000000000000` : `STATUS_ILLEGAL_ARG`: `X00` does not only contain lock data bits
|                   * if the given lock does not only specify the lock data
|       * the lock of the file system will be remembered in the `FS_LOCK` register
INT_FS_LOCK=46
|   * `47`: unlock file-system
|       * if the file system is not locked with the given lock the operation will fail
|           * if the `FS_LOCK` is `UHEX-0000000000000000` : `LOCK_NO_LOCK`, the operation will always try to remove the lock of the element
|       * if the file system is locked with a shared lock:
|           * if this is the last lock, the shared lock will be removed
|           * else the shared lock counter will be decremented
|       * `X00` will be set to `-1` on error
|           * the `STATUS` register will be flagged:
|               * `UHEX-0800000000000000` : `STATUS_ELEMENT_LOCKED`: operation was denied because of lock
|                   * if the file system is locked with a different lock or not locked at all
|               * `UHEX-1000000000000000` : `STATUS_IO_ERR`: an unspecified IO error occurred
|                   * if some IO error occurred
INT_FS_UNLOCK=47
|   * `48`: to get the time in milliseconds
|       * `X00` will contain the time in milliseconds or `-1` if not available
INT_TIME_GET=48
|   * `49`: to wait the given time in nanoseconds
|       * `X00` contain the number of nanoseconds to wait (only values from `0` to `999999999` are allowed)
|       * `X01` contain the number of seconds to wait
|       * `X00` and `X01` will contain the remaining time (both `0` if it finished waiting)
|       * `X02` will be `1` if the call was successfully and `0` if something went wrong
|           * if `X02` is `1` the remaining time will always be `0`
|           * if `X02` is `0` the remaining time will be greater `0`
|       * `X00` will not be negative if the progress waited too long
INT_TIME_WAIT=49
|   * `50`: random
|       * `X00` will be filled with random bits
INT_RANDOM=50
|   * `51`: memory copy
|       * copies a block of memory
|       * this function has undefined behavior if the two blocks overlap
|       * `X00` points to the target memory block
|       * `X01` points to the source memory block
|       * `X02` has the length of bytes to bee copied
INT_MEMORY_COPY=51
|   * `52`: memory move
|       * copies a block of memory
|       * this function makes sure, that the original values of the source block are copied to the target block (even if the two block overlap)
|       * `X00` points to the target memory block
|       * `X01` points to the source memory block
|       * `X02` has the length of bytes to bee copied
INT_MEMORY_MOVE=52
|   * `53`: memory byte set
|       * sets a memory block to the given byte-value
|       * `X00` points to the block
|       * `X01` the first byte contains the value to be written to each byte
|       * `X02` contains the length in bytes
INT_MEMORY_BSET=53
|   * `54`: memory set
|       * sets a memory block to the given int64-value
|       * `X00` points to the block
|       * `X01` contains the value to be written to each element
|       * `X02` contains the count of elements to be set
INT_MEMORY_SET=54
|   * `55`: string length
|       * `X00` points to the STRING
|       * `X00` will be set to the length of the string/ the (byte-)offset of the `'\0'` character
INT_STRING_LENGTH=55
|   * `56`: string compare
|       * `X00` points to the first STRING
|       * `X01` points to the second STRING
|       * `X00` will be set to zero if both are equal STRINGs, a value greater zero if the first is greater and below zero if the second is greater
|           * a STRING is greater if the first mismatching char has numeric greater value
INT_STRING_COMPARE=56
|   * `57`: number to string
|       * `X00` is set to the number to convert
|       * `X01` is points to the buffer to be filled with the number in a STRING format
|       * `X02` contains the base of the number system
|           * the minimum base is `2`
|           * the maximum base is `36`
|           * other values lead to undefined behavior
|       * `X00` will be set to the length of the STRING
INT_NUMBER_TO_STRING=57
|   * `58`: floating point number to string
|       * `X00` is set to the number to convert
|       * `X02` contains the maximum amount of digits to be used to represent the floating point number
|       * `X01` is points to the buffer to be filled with the number in a STRING format
INT_FPNUMBER_TO_STRING=58
|   * `59`: string to number
|       * `X00` points to the STRING
|       * `X01` points to the base of the number system
|           * (for example `10` for the decimal system or `2` for the binary system)
|       * `X00` will be set to the converted number
|       * `X01` will point to the end of the number-STRING
|           * this might be the `\0` terminating character
|       * if the STRING contains illegal characters or the base is not valid, the behavior is undefined
|       * this function will ignore leading space characters
INT_STRING_TO_NUMBER=59
|   * `60`: string to floating point number
|       * `X00` points to the STRING
|       * `X00` will be set to the converted number
|       * `X01` will point to the end of the number-STRING
|           * this might be the `\0` terminating character
|       * if the STRING contains illegal characters or the base is not valid, the behavior is undefined
|       * this function will ignore leading space characters
INT_STRING_TO_FPNUMBER=60
|   * `61`: format string
|       * `X00` is set to the STRING input
|       * `X01` contains the buffer for the STRING output
|       * `X02` is the current size of the buffer in bytes
|       * the register `X03..XNN` are for the formatting parameters
|           * if there are mor parameters used then there are registers the behavior is undefined.
|               * that leads to a maximum of 248 parameters.
|       * `X00` will be set to the length of the output string
|       * `X01` will be set to the output buffer
|       * `X02` will be set to the new buffer size in bytes
|       * if the buffer could not be resized, `X00` will be set to `-1`
|           * `X02` will be set to the current size of the buffer
|       * formatting:
|           * everything, which can not be formatted, will be delegated to the target buffer
|           * `%s`: the next argument points to a STRING, which should be inserted here
|           * `%c`: the next argument points to a character, which should be inserted here
|               * note that characters may contain more than one byte
|                   * `BIN-0.......` -> one byte (equivalent to an ASCII character)
|                   * `BIN-10......` -> invalid, treated as one byte
|                   * `BIN-110.....` -> two bytes
|                   * `BIN-1110....` -> three bytes
|                   * `BIN-11110...` -> four bytes
|                   * `BIN-111110..` -> invalid, treated as five byte
|                   * `BIN-1111110.` -> invalid, treated as six byte
|                   * `BIN-11111110` -> invalid, treated as seven byte
|                   * `BIN-11111111` -> invalid, treated as eight byte
|           * `%B`: the next argument points to a byte, which should be inserted here (without being converted to a STRING)
|           * `%d`: the next argument contains a number, which should be converted to a STRING using the decimal number system and than be inserted here
|           * `%f`: the next argument contains a floating point number, which should be converted to a STRING and than be inserted here
|           * `%p`: the next argument contains a pointer, which should be converted to a STRING
|               * if not the pointer will be converted by placing a `"p-"` and then the pointer-number converted to a STRING using the hexadecimal number system
|               * if the pointer is `-1` it will be converted to the STRING `"---"`
|           * `%h`: the next argument contains a number, which should be converted to a STRING using the hexadecimal number system and than be inserted here
|           * `%b`: the next argument contains a number, which should be converted to a STRING using the binary number system and than be inserted here
|           * `%o`: the next argument contains a number, which should be converted to a STRING using the octal number system and than be inserted here
INT_STRING_FORMAT=61
|   * `62`: STRING to U8-STRING
|       * `X00` contains the STRING
|       * `X01` points to a buffer for the U8-SRING
|       * `X02` is set to the size of the size of the buffer
|       * `X01` will point to the U8-STRING
|       * `X02` will be set to the U8-STRING buffer size
|       * `X03` will point to the `\0` character of the U8-STRING
INT_STR_TO_U8STR=62
|   * `63`: U8-STRING to STRING
|       * `X00` contains the U8-STRING
|       * `X01` points to a buffer for the SRING
|       * `X02` is set to the size of the size of the buffer
|       * `X01` will point to the STRING
|       * `X02` will be set to the STRING buffer size
|       * `X03` will point to the `\0` character of the STRING
INT_U8STR_TO_STR=63
|   * `64`: load file
|       * `X00` is set to the path (inclusive name) of the file
|       * `X00` will point to the memory block, in which the file has been loaded
|       * `X01` will be set to the length of the file (and the memory block)
|       * when an error occurred `X00` will be set to `-1`
INT_LOAD_FILE=64
|   * `65`: get file 
|       * similar like `64` (`INT_LOAD_FILE`) this interrupt loads a file for the program.
|           * the only difference is that this interrupt remembers which files has been loaded
|           * if the interrupt is executed multiple times with the same file, it will return every time the same memory block.
|           * file changes after the file has already been loaded with this interrupt are ignored.
|               * only if the file moved or deleted the interrupt recognize the change.
|               * if the file gets moved and the new file path is used the interrupt recognizes the old file
|               * thus the same memory block is still returned if the file gets moved and the new path is used
|                   * thus changes in the content of the file are never recognized
|           * this interrupt does not recognize files loaded with the `64` (`INT_LOAD_FILE`) interrupt.
|       * `X00` is set to the path (inclusive name) of the file
|       * `X00` will point to the memory block, in which the file has been loaded
|       * `X01` will be set to the length of the file (and the memory block)
|       * `X02` will be set to `1` if the file has been loaded as result of this interrupt and `0` if the file was previously loaded
|       * when an error occurred `X00` will be set to `-1`
INT_GET_FILE=65
|   the total number of default interrupts
INTERRUPT_COUNT=66
|   the maximum/greatest number
MAX_VALUE=9223372036854775807
|   the minimum/lowest number
MIN_VALUE=-9223372036854775808
|   the STREAM-ID of the default input stream
|       this stream is initially open and does not support write operations
|       this stream is no fs-stream (thus the position can not be set)
STD_IN=0
|   the STREAM-ID of the default output stream
|       this stream is initially open and does not support read operations
|       this stream is no fs-stream (thus the position can not be set)
STD_OUT=1
|   the STREAM-ID of the default log output stream
|       this stream is initially open and does not support read operations
|       this stream is no fs-stream (thus the position can not be set)
STD_LOG=2
|   open option: open file for read access
OPEN_READ=1
|   open option: open file for write access
OPEN_WRITE=2
|   open option: open file for append access (implicit set of `OPEN_WRITE`)
OPEN_APPEND=4
|   open option: open file or create file (needs `OPEN_WRITE`, not compatible with `OPEN_NEW_FILE`)
OPEN_CREATE=8
|   open option: fail if file already exists or create the file (needs `OPEN_WRITE`, not compatible with `OPEN_CREATE`)
OPEN_NEW_FILE=16
|   open option: if the file already exists, remove its content (needs `OPEN_WRITE`)
OPEN_TRUNCATE=32
|   the offset of the fs-element file pointer of the stream
FS_STREAM_OFFSET_FILE=0
|   the offset of the current position of the stream
FS_STREAM_OFFSET_POS=8
|   the offset of the ID of a fs-element
FS_ELEMENT_OFFSET_ID=0
|   the offset of the lock to be used of a fs-element
FS_ELEMENT_OFFSET_LOCK=8
|   the lock flag to specify that no read operations are allowed
LOCK_NO_READ_ALLOWED=4294967296
|   the lock flag to specify that no write operations are allowed
LOCK_NO_WRITE_ALLOWED_LOCK=8589934592
|   the lock flag to specify that the element is not allowed to be deleted
LOCK_NO_DELETE_ALLOWED_LOCK=17179869184
|   the lock flag to specify that no direct metadata changes are allowed
|       indirect metadata changes are still allowed (with write operations setting the last mod (and last meta mod) time)
LOCK_NO_META_CHANGE_ALLOWED_LOCK=34359738368
|   the lock flag to specify that the lock is a shared lock
LOCK_SHARED_LOCK=4611686018427387904
|   the lock flag to specify that the lock is a lock
|       this flag allows to have a exclusive lock without blocking any operations
LOCK_LOCKED_LOCK=-9223372036854775808
|   this number is used to specify when no lock should be used
LOCK_NO_LOCK=0
|   the flag marks an element as folder
FLAG_FOLDER=1
|   the flag marks an element as file
FLAG_FILE=2
|   the flag marks an element as link
|       note that links are also marked as folder or file
FLAG_LINK=4
|   the flag marks an element as read only
FLAG_READ_ONLY=8
|   the flag marks an element as executable
FLAG_EXECUTABLE=16
|   the flag marks an element as hidden
FLAG_HIDDEN=32
|   the flag marks an folder as sorted
|       this flag does not have any real use yet
FLAG_FOLDER_SORTED=64
|   the flag marks an file as encrypted
|       this flag does not have any real use for the file system
FLAG_FILE_ENCRYPTED=128
|   a floating-point-number to specify a Not-A-Number constant
FP_NAN=9222809086901354496
|   the maximum/greatest floating-point-number
FP_MAX_VALUE=9218868437227405311
|   the minimum/lowest floating-point-number
FP_MIN_VALUE=1
|   the floating-point-number for positiv infinity
FP_POS_INFINITY=9218868437227405312
|   the floating-point-number for negative infinity
FP_NEG_INFINITY=-4503599627370496
|   the status flag used when on the last compare (CMP A, B) A was lower than B
STATUS_LOWER=1
|   the status flag used when on the last compare (CMP A, B) A was greater than B
STATUS_GREATHER=2
|   the status flag used when on the last compare (CMP A, B) A was equal to B
STATUS_EQUAL=4
|   the status flag used when an overflow occurred
STATUS_CARRY=8
|   the status flag used when an mathematical (arithmetic or logic) operation had zero as result
STATUS_ZERO=16
|   the status flag used when an mathematical operation had a NaN as result
STATUS_NAN=32
|   the status flag used when on the last bit-compare (BCP A, B) A & B was B (and B != zero)
STATUS_ALL_BITS=64
|   the status flag used when on the last bit-compare (BCP A, B) A & B was not zero
STATUS_SOME_BITS=128
|   the status flag used when on the last bit-compare (BCP A, B) A & B was zero
STATUS_NONE_BITS=256
|   the status flag indicates a invalid fs-element type (file expected but folder was used or in reverse)
STATUS_ELEMENT_WRONG_TYPE=18014398509481984
|   the status flag indicates that a element was ought to exist but did not exist
STATUS_ELEMENT_NOT_EXIST=36028797018963968
|   the status flag indicates that a element was not ought to exist but did already exist
STATUS_ELEMENT_ALREADY_EXIST=72057594037927936
|   the status flag indicates that the file system could not reserve enough space for some reason
STATUS_OUT_OF_SPACE=144115188075855872
|   the status flag indicates that a element was marked as read only, but a write operation was tried
STATUS_READ_ONLY=288230376151711744
|   the status flag indicates that a different lock was used or the lock of the element forbid the tried operation
STATUS_ELEMENT_LOCKED=576460752303423488
|   the status flag indicates that an undefined IO error occurred
STATUS_IO_ERR=1152921504606846976
|   the status flag indicates that an interrupt was misused
STATUS_ILLEGAL_ARG=2305843009213693952
|   the status flag indicates the system could not reserve enough memory
STATUS_OUT_OF_MEMORY=4611686018427387904
|   the status flag indicates that some unspecified error occurred
|      this flag will not be generated by default interrupts
STATUS_ERROR=-9223372036854775808
