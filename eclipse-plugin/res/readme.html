
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="author" content="MarkdownViewer++" />
        <title>README.md</title>
        <style type="text/css">
            
/* Avoid page breaks inside the most common attributes, especially for exports (i.e. PDF) */
td, h1, h2, h3, h4, h5, p, ul, ol, li {
    page-break-inside: avoid; 
}

        </style>
      </head>
    <body>
        <h1 id="primitive-code">primitive-code</h1>
<p>a register based assembler language</p>
<p>the assembler language for the Primitive-Virtual-Machine</p>
<h2 id="start">Start</h2>
<ul>
<li>A primitive-assembler-code file can be assembled to a primitive-machine-code file.</li>
<li>A primitive-machine-code file can be executed with a primitive-virtual-machine.
<ul>
<li>the <code>X00</code> register will be set to the number of arguments</li>
<li>the <code>X01</code> register will point to the arguments</li>
<li>the arguments will point to STRINGs
<ul>
<li>the first argument will be the program itself, all beyond will be the arguments of the program</li>
<li>example:
<ul>
<li><code>my_program.pmc --example value --other=val</code></li>
<li><code>X00 &lt;- 4</code></li>
<li><code>[X01] &lt;- ADDRESS_OF &quot;my_program.pmc\0&quot;</code></li>
<li><code>[X01 + 8] &lt;- ADDRESS_OF &quot;--example\0&quot;</code></li>
<li><code>[X01 + 16] &lt;- ADDRESS_OF &quot;value\0&quot;</code></li>
<li><code>[X01 + 24] &lt;- ADDRESS_OF &quot;--other=val\0&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>the <code>INTCNT</code> register will be set to <code>#INTERRUPT_COUNT</code></li>
<li>the interrupt-table of <code>INTP</code> will be initialized and every entry will be set to <code>-1</code>
<ul>
<li>so by default the default interrupts will be called, but they can be easily overwritten</li>
</ul>
</li>
<li>the <code>SP</code> will be either be set to <code>-1</code> or <code>SP</code> will point to the start of an memory block (with an undefined size)</li>
</ul>
</li>
</ul>
<h2 id="primitive-virtual-machine">Primitive virtual machine</h2>
<ul>
<li>the primitive virtual machine has the following registers:
<ul>
<li><code>IP</code>
<ul>
<li><code>64-bit</code></li>
<li>the instruction pointer points to the command to be executed</li>
<li>initialized with the begin of the loaded machine code file</li>
</ul>
</li>
<li><code>SP</code>
<ul>
<li><code>64-bit</code></li>
<li>the stack pointer points to the command to be executed</li>
<li>initialized with <code>-1</code> or the begin of a memory block</li>
</ul>
</li>
<li><code>STATUS</code>
<ul>
<li><code>64-bit</code></li>
<li>saves some results of operations</li>
<li><code>HEX-0000000000000001</code> : <code>LOWER</code>: if on the last <code>CMP A, B</code> A was lower than B</li>
<li><code>HEX-0000000000000002</code> : <code>GREATHER</code>: if on the last <code>CMP A, B</code> A was greater than B</li>
<li><code>HEX-0000000000000004</code> : <code>EQUAL</code>: if on the last <code>CMP A, B</code> A was greater than B</li>
<li><code>HEX-0000000000000008</code> : <code>CARRY</code>: if an overflow was detected</li>
<li><code>HEX-0000000000000010</code> : <code>ZERO</code>: if the last arithmetic or logical operation leaded to zero (<code>HEX-0000000000000000</code>)</li>
<li><code>HEX-0000000000000020</code> : <code>NAN</code>: if the last floating point operation leaded to a NaN value</li>
<li>initialized with <code>0</code></li>
</ul>
</li>
<li><code>INTCNT</code>
<ul>
<li><code>64-bit</code></li>
<li>saves the number of allowed interrupts (<code>0..(INTCNT-1)</code> are allowed)
<ul>
<li>all other will call the <code>INT-ERRORS_ILLEGAL_INTERRUPT</code> interrupt</li>
</ul>
</li>
<li>initialized with the interrupt count which can be used as default interrupts</li>
</ul>
</li>
<li><code>INTP</code>
<ul>
<li><code>64-bit</code></li>
<li>points to the interrupt-table</li>
<li>initialized with the interrupt table
<ul>
<li>this table has a memory size of  <code>INTCNT * 8</code> bytes</li>
<li>all entries of the table are initialized with <code>-1</code></li>
</ul>
</li>
</ul>
</li>
<li><code>X[00..FA]</code>
<ul>
<li><code>251 * 64-bit</code></li>
<li>number registers, for free use</li>
<li><code>X00</code> is initialized with the pointer to the program arguments</li>
<li><code>X01</code> is initialized with the count of program arguments</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="numbers">NUMBERS:</h2>
<ul>
<li>numbers can be assigned to constants, used as a parameter or inside of a parameter as offset</li>
<li>to use a decimal number it is possible to write just the number.
<ul>
<li>to use a negative decimal number put a <code>-</code> before the number</li>
</ul>
</li>
<li>it is possible to specify the number system, by putting the correct keyword before the number:
<ul>
<li>for binary (base 2): <code>BIN-</code></li>
<li>for octal (base 8): <code>OCT-</code></li>
<li>for decimal (base 10): <code>DEC-</code></li>
<li>for hexadecimal (base 16): <code>HEX-</code>
<ul>
<li>to use a unsigned hexadecimal number, put a <code>U</code> before the prefix</li>
</ul>
</li>
</ul>
</li>
<li>to use negative numbers, put a <code>N</code> before the prefix of the number system</li>
</ul>
<h2 id="constants">CONSTANTS:</h2>
<ul>
<li>except for the <code>--POS--</code> constant all other constants can be overwritten and removed</li>
<li>to define constants write a <code>'#'</code> as prefix</li>
<li>to load the constant of an other file
<ul>
<li><code>~READ_SYM &quot;&lt;FILE&gt;&quot; [...] &gt;</code>
<ul>
<li>[...]: no, one or multiple of the following:
<ul>
<li><code>#&lt;CONSTANT_PREFIX&gt;</code>
<ul>
<li>to set before all read constants the given prefix</li>
</ul>
</li>
<li><code>--MY_CONSTS--</code>
<ul>
<li>to not use the default constant, but the constants which are now set</li>
<li>only possible, when the file is a primitive source code file</li>
</ul>
</li>
<li><code>#ADD~&lt;NAME&gt; &lt;VALUE&gt;</code>
<ul>
<li>to add the a constant with the given name and value to the start-constants of the file</li>
<li>only possible, when the file is a primitive source code file</li>
</ul>
</li>
<li><code>--SOURCE--</code>
<ul>
<li>to set the type of the file to a primitive source code file</li>
</ul>
</li>
<li><code>--SYMBOL--</code>
<ul>
<li>to set the type of the file to a primitive symbol file</li>
</ul>
</li>
</ul>
</li>
<li>if the file type has not been set, the file must end with one of these:
<ul>
<li><code>.psf</code>: is assumed to be a primitive symbol file</li>
<li><code>.psc</code>: is assumed to be a primitive source code file</li>
<li>any other end will cause an error</li>
</ul>
</li>
<li>if &quot;<FILE>&quot; is &quot;[THIS]&quot; the file, which is now parsed is used.</li>
</ul>
</li>
</ul>
</li>
<li>to set define an export constant
<ul>
<li><code>#EXP~&lt;NAME&gt; &lt;VALUE&gt;</code></li>
<li>an export constant can be used like a normal constant</li>
<li>when an export constant is deleted or overwritten like an normal constant, this will not affect the export</li>
<li>to delete an export constant, write <code>#EXP~&lt;NAME&gt; ~DEL</code>
<ul>
<li>then it will be deleted as normal and as export constant</li>
</ul>
</li>
<li>to change a normal constant to an export constant, just redefine it: <code>#EXP~&lt;NAME&gt; &lt;NAME&gt;</code></li>
</ul>
</li>
<li>predefined constants:</li>
</ul>
<pre><code>        --POS-- :                           the actual length of the binary code in bytes
        INT_ERRORS_ILLEGAL_INTERRUPT :      0
        INT_ERRORS_UNKNOWN_COMMAND :        1
        INT_ERRORS_ILLEGAL_MEMORY :         2
        INT_ERRORS_ARITHMETIC_ERROR :       3
        INT_EXIT :                          4
        INT_MEMORY_ALLOC :                  5
        INT_MEMORY_REALLOC :                6
        INT_MEMORY_FREE :                   7
        INT_STREAMS_NEW_IN :                8
        INT_STREAMS_NEW_OUT :               9
        INT_STREAMS_NEW_APPEND :            10
        INT_STREAMS_NEW_IN_OUT :            11
        INT_STREAMS_NEW_APPEND_IN_OUT :     12
        INT_STREAMS_WRITE :                 13
        INT_STREAMS_READ :                  14
        INT_STREAMS_SYNC_STREAM :           15
        INT_STREAMS_CLOSE_STREAM :          16
        INT_STREAMS_GET_POS :               17
        INT_STREAMS_SET_POS :               18
        INT_STREAMS_SET_POS_TO_END :        19
        INT_STREAMS_REM :                   20
        INT_STREAMS_MK_DIR :                21
        INT_STREAMS_REM_DIR :               22
        INT_TIME_GET :                      23
        INT_TIME_WAIT :                     24
        INT_SOCKET_CLIENT_CREATE :          25
        INT_SOCKET_CLIENT_CONNECT :         26
        INT_SOCKET_SERVER_CREATE :          27
        INT_SOCKET_SERVER_LISTEN :          28
        INT_SOCKET_SERVER_ACCEPT :          29
        INT_RANDOM :                        30
        INT_MEMORY_COPY :                   31
        INT_MEMORY_MOVE :                   32
        INT_MEMORY_BSET :                   33
        INT_MEMORY_SET :                    34
        INT_STRING_LENGTH :                 35
        INT_NUMBER_TO_STRING :              36
        INT_FPNUMBER_TO_STRING :            37
        INT_STRING_TO_NUMBER :              38
        INT_STRING_TO_FPNUMBER :            39
        INT_STRING_FORMAT :                 40
        INT_LOAD_FILE :                     41
        INTERRUPT_COUNT :                   42
        MAX_VALUE :                     HEX-7FFFFFFFFFFFFFFF
        MIN_VALUE :                    NHEX-8000000000000000
        STD_IN :                            0
        STD_OUT :                           1
        STD_LOG :                           2
        FP_NAN :                       UHEX-7FFE000000000000
        FP_MAX_VALUE :                 UHEX-7FEFFFFFFFFFFFFF
        FP_MIN_VALUE :                 UHEX-0000000000000001
        FP_POS_INFINITY :              UHEX-7FF0000000000000
        FP_NEG_INFINITY :              UHEX-FFF0000000000000</code></pre>
<h2 id="strings">STRINGS:</h2>
<ul>
<li>a string is an array of multiple characters of the <code>UTF-8</code> encoding</li>
<li>a string ends with a <code>'\0'</code> character</li>
</ul>
<h2 id="commands">COMMANDS:</h2>
<p><code>: [...] &gt;</code></p>
<ul>
<li>a constant pool contains a constant sequence of bytes
<ul>
<li>to write an constant, write the constant and than <code>WRITE</code></li>
<li>to write an number, just write the number</li>
<li>to write single bytes put a <code>B-</code> before the number
<ul>
<li>then only values from <code>0</code> to <code>255</code> (both inclusive) can be written.</li>
<li>values outside of this range will cause an error</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>MOV &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>copies the value of the second parameter to the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p2</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>01 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>MVAD &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt; , &lt;CONST_PARAM&gt;</code></p>
<ul>
<li>copies the value of the second parameter plus the third parameter to the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p2 + p3</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>29 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
<li><code>&lt;P3.NUM_NUM&gt;</code></li>
</ul>
</li>
</ul>
<p><code>LEA &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>sets the first parameter of the value of the second parameter plus the instruction pointer</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p2 + IP</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>28 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>SWAP &lt;NO_CONST_PARAM&gt; , &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>swaps the value of the first and the second parameter</li>
<li>definition:
<ul>
<li><code>ZW &lt;- p1</code></li>
<li><code>p1 &lt;- p2</code></li>
<li><code>p2 &lt;- ZW</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>27 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>ADD &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>adds the values of both parameters and stores the sum in the first parameter</li>
<li>definition:
<ul>
<li><code>if ((p1 &gt; 0) &amp; (p2 &gt; 0) &amp; ((p1 + p2) &lt; 0)) | ((p1 &lt; 0) &amp; (p2 &lt; 0) &amp; ((p1 + p2) &gt; 0))</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 + p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>02 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>ADDC &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>adds the values of both parameters and the carry flag and stores the sum in the first parameter</li>
<li>definition:
<ul>
<li><code>if ((p1 &gt; 0) &amp; ((p2 + CARRY) &gt; 0) &amp; ((p1 + p2 + CARRY) &lt; 0)) | ((p1 &lt; 0) &amp; ((p2 + CARRY) &lt; 0) &amp; ((p1 + (p2 + CARRY)) &gt; 0))</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 + (p2 + CARRY)</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>30 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>ADDFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>adds the floating point values of both parameters and stores the floating point sum in the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 fp-add p2</code></li>
<li><code>if p1 = 0.0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
<li><code>NAN &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 = NaN</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
<li><code>NAN &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
<li><code>NAN &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>32 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>SUB &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>subtracts the second parameter from the first parameter and stores the result in the first parameter</li>
<li>definition:
<ul>
<li><code>if ((p1 &gt; 0) &amp; (p2 &lt; 0) &amp; ((p1 - p2) &lt; 0)) | ((p1 &lt; 0) &amp; (p2 &gt; 0) &amp; ((p1 - p2) &gt; 0))</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 - p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>03 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>SUBC &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>subtracts the second parameter with the carry flag from the first parameter and stores the result in the first parameter</li>
<li>definition:
<ul>
<li><code>if (p1 &gt; 0) &amp; ((p2 + CARRY) &lt; 0) &amp; ((p1 - (p2 + CARRY)) &lt; 0)) | ((p1 &lt; 0) &amp; (p2 &gt; 0) &amp; ((p1 - (p2 + CARRY)) &gt; 0))</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 - (p2 + CARRY)</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>31 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>SUBFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>subtracts the second fp-parameter from the first fp-parameter and stores the fp-result in the first fp-parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 fp-sub p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>if p1 = NaN</code>
<ul>
<li><code>NAN &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>NAN &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>33 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>MUL &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>multiplies the first parameter with the second and stores the result in the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 * p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>04 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>UMUL &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>like MUL, but uses the parameters as unsigned parameters</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 u-mul p2</code>
<ul>
<li><code>if p1 = 0</code></li>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>39 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>MULFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>multiplies the first fp parameter with the second fp and stores the fp result in the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 fp-mul p2</code></li>
<li><code>if p1 = 0.0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>if p1 = NaN</code>
<ul>
<li><code>NAN &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>NAN &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>34 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>DIV &lt;NO_CONST_PARAM&gt; , &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>divides the first parameter with the second and stores the result in the first parameter and the reminder in the second parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 / p2</code></li>
<li><code>p2 &lt;- p1 mod p2</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>05 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>UDIV &lt;NO_CONST_PARAM&gt; , &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>like DIV, but uses the parameters as unsigned parameters</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 udiv p2</code></li>
<li><code>p2 &lt;- p1 mod p2</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>3A &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>DIVFP &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>divides the first fp-parameter with the second fp and stores the fp-result in the first fp-parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 fp-div p2</code></li>
<li><code>if p1 = 0.0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>if p1 = NaN</code>
<ul>
<li><code>NAN &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>NAN &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>35 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>AND &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>uses the logical AND operator with the first and the second parameter and stores the result in the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 &amp; p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>06 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>OR &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>uses the logical OR operator with the first and the second parameter and stores the result in the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 | p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>07 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>XOR &lt;NO_CONST_PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>uses the logical OR operator with the first and the second parameter and stores the result in the first parameter</li>
<li>definition:
<ul>
<li><code>p1 &lt;- p1 ^ p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>08 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>LSH &lt;NO_CONST_PARAM&gt;, &lt;PARAM&gt;</code></p>
<ul>
<li>shifts bits of the parameter logically left</li>
<li>definition:
<ul>
<li><code>if ((p1 &lt;&lt; p2) &gt;&gt; p2) = p1</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 &lt;&lt; p2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>0B &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>RLSH &lt;NO_CONST_PARAM&gt;, &lt;PARAM&gt;</code></p>
<ul>
<li>shifts bits of the parameter logically right</li>
<li>definition:
<ul>
<li><code>if ((p1 &gt;&gt; p2) &lt;&lt; p2) = p1</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 &gt;&gt; 1</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>0C &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>RASH &lt;NO_CONST_PARAM&gt;, &lt;PARAM&gt;</code></p>
<ul>
<li>shifts bits of the parameter arithmetic right</li>
<li>definition:
<ul>
<li><code>if ((p1 &gt;&gt;&gt; p2) &lt;&lt;&lt; p2) = p1</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 &gt;&gt;&gt; 2</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>0D &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>NOT &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>uses the logical NOT operator with every bit of the parameter and stores the result in the parameter</li>
<li>this instruction works like <code>XOR p1, -1</code></li>
<li>definition:
<ul>
<li><code>p1 &lt;- ~ p1</code></li>
<li><code>if p1 = 0</code>
<ul>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>09 &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>NEG &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>uses the arithmetic negation operation with the parameter and stores the result in the parameter</li>
<li>this instruction works like <code>MUL p1, -1</code></li>
<li>definition:
<ul>
<li><code>if p1 = 0</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>if p1 = #MIN-VALUE</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- 0 - p1</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>0A &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>JMP &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label</li>
<li>definition:
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>10 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPEQ &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last compare operation compared two equal values</li>
<li>definition:
<ul>
<li><code>if EQUAL</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>11 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPNE &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last compare operation compared two different values</li>
<li>definition:
<ul>
<li><code>if EQUAL</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>12 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPGT &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last compare result was greater</li>
<li>definition:
<ul>
<li><code>if GREATHER</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>13 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPGE &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last compare result was not lower</li>
<li>definition:
<ul>
<li><code>if GREATHER | EQUAL</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>14 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPLT &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last compare result was lower</li>
<li>definition:
<ul>
<li><code>if LOWER</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>15 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPLE &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last compare result was not greater</li>
<li>definition:
<ul>
<li><code>if LOWER | EQUAL</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>16 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPCS &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last carry flag is set</li>
<li>definition:
<ul>
<li><code>if CARRY</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>17 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPCC &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last carry flag is cleared</li>
<li>definition:
<ul>
<li><code>if CARRY</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>18 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPZS &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last zero flag is set</li>
<li>definition:
<ul>
<li><code>if ZERO</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>19 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPZC &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last zero flag is cleared</li>
<li>definition:
<ul>
<li><code>if ! ZERO</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>1A 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPNAN &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last NaN flag is set</li>
<li>definition:
<ul>
<li><code>if NAN</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>1B 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>JMPAN &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the command after the label if the last NaN flag is cleared</li>
<li>definition:
<ul>
<li><code>if ! NAN</code>
<ul>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>note that all jumps and calls are relative, so it does not matter if the code was loaded to the memory address 0 or not</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>1C 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>CALL &lt;LABEL&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the label</li>
<li>and pushes the current instruction pointer to the stack</li>
<li>definition:
<ul>
<li><code>[SP] &lt;- IP</code></li>
<li><code>SP &lt;- SP + 8</code></li>
<li><code>IP &lt;- IP + RELATIVE_LABEL</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>20 00 00 00 00 00 00 00</code></li>
<li><code>&lt;RELATIVE_LABEL&gt;</code></li>
</ul>
</li>
</ul>
<p><code>CALO &lt;PARAM&gt;, &lt;LABEL/CONST_PARAM&gt;</code></p>
<ul>
<li>sets the instruction pointer to position of the label</li>
<li>and pushes the current instruction pointer to the stack
<ul>
<li><code>[SP] &lt;- IP</code></li>
<li><code>SP &lt;- SP + 8</code></li>
<li><code>IP &lt;- p1 + (p2)</code>
<ul>
<li>the call will not be made relative from this position, so the label remains relative to the start of the file it is declared in</li>
</ul>
</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>2A &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>&lt;P2.NUM_NUM&gt;</code></li>
</ul>
</li>
</ul>
<p><code>CMP &lt;PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>compares the two values and stores the result in the status register</li>
<li>definition:
<ul>
<li><code>if p1 &gt; p2</code>
<ul>
<li><code>GREATHER &lt;- 1</code></li>
<li><code>LOWER &lt;- 0</code></li>
<li><code>EQUAL &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 &lt; p2</code>
<ul>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>LOWER &lt;- 1</code></li>
<li><code>EQUAL &lt;- 0</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>LOWER &lt;- 0</code></li>
<li><code>EQUAL &lt;- 1</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>21 &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>CMPFP &lt;PARAM&gt; , &lt;PARAM&gt;</code></p>
<ul>
<li>compares the two floating point values and stores the result in the status register</li>
<li>definition:
<ul>
<li><code>if p1 &gt; p2</code>
<ul>
<li><code>GREATHER &lt;- 1</code></li>
<li><code>LOWER &lt;- 0</code></li>
<li><code>NaN &lt;- 0</code></li>
<li><code>EQUAL &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 &lt; p2</code>
<ul>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>LOWER &lt;- 1</code></li>
<li><code>NaN &lt;- 0</code></li>
<li><code>EQUAL &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 = NaN | p2 = NaN</code>
<ul>
<li><code>LOWER &lt;- 0</code></li>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>NaN &lt;- 1</code></li>
<li><code>EQUAL &lt;- 0</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>LOWER &lt;- 0</code></li>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>NaN &lt;- 0</code></li>
<li><code>EQUAL &lt;- 1</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>2B &lt;B-P1.TYPE&gt; &lt;B-P2.TYPE&gt; 00 &lt;B-P2.OFF_REG|00&gt; &lt;B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|B-P2.NUM_REG|B-P2.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
<li><code>[P2.NUM_NUM]</code></li>
<li><code>[P2.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>RET</code></p>
<ul>
<li>sets the instruction pointer to the position which was secured in the stack</li>
<li>definition:
<ul>
<li><code>SP &lt;- SP - 8</code></li>
<li><code>IP &lt;- [SP]</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>22 00 00 00 00 00 00 00</code></li>
</ul>
</li>
</ul>
<p><code>IRET</code></p>
<ul>
<li>returns from an interrupt</li>
<li>definition:
<ul>
<li><code>ZW &lt;- X0A</code></li>
<li><code>IP &lt;- [X0A]</code></li>
<li><code>SP &lt;- [X0A + 8]</code></li>
<li><code>STATUS &lt;- [X0A + 16]</code></li>
<li><code>INTCNT &lt;- [X0A + 24]</code></li>
<li><code>INTP &lt;- [X0A + 32]</code></li>
<li><code>X00 &lt;- [X0A + 40]</code></li>
<li><code>X01 &lt;- [X0A + 48]</code></li>
<li><code>X02 &lt;- [X0A + 56]</code></li>
<li><code>X03 &lt;- [X0A + 64]</code></li>
<li><code>X04 &lt;- [X0A + 72]</code></li>
<li><code>X05 &lt;- [X0A + 80]</code></li>
<li><code>X06 &lt;- [X0A + 88]</code></li>
<li><code>X07 &lt;- [X0A + 98]</code></li>
<li><code>X08 &lt;- [X0A + 104]</code></li>
<li><code>X09 &lt;- [X0A + 112]</code></li>
<li><code>X0A &lt;- [X0A + 120]</code></li>
<li><code>FREE ZW</code>
<ul>
<li>this does not use the free interrupt, but works like the default free interrupt (without calling the interrupt (what could cause an infinite recursion))</li>
</ul>
</li>
</ul>
</li>
<li>binary:
<ul>
<li>`23 00 00 00 00 00 00 00</li>
</ul>
</li>
</ul>
<p><code>INT &lt;PARAM&gt;</code></p>
<ul>
<li>calls the interrupt specified by the parameter</li>
<li>definition:
<ul>
<li><code>ZW &lt;- MEM-ALLOC{size=128}</code></li>
<li><code>[ZW] &lt;- IP</code></li>
<li><code>[ZW + 8] &lt;- SP</code></li>
<li><code>[ZW + 16] &lt;- STATUS</code></li>
<li><code>[ZW + 24] &lt;- INTCNT</code></li>
<li><code>[ZW + 32] &lt;- INTP</code></li>
<li><code>[ZW + 40] &lt;- X00</code></li>
<li><code>[ZW + 48] &lt;- X01</code></li>
<li><code>[ZW + 56] &lt;- X02</code></li>
<li><code>[ZW + 64] &lt;- X03</code></li>
<li><code>[ZW + 72] &lt;- X04</code></li>
<li><code>[ZW + 80] &lt;- X05</code></li>
<li><code>[ZW + 88] &lt;- X06</code></li>
<li><code>[ZW + 96] &lt;- X07</code></li>
<li><code>[ZW + 104] &lt;- X08</code></li>
<li><code>[ZW + 112] &lt;- X09</code></li>
<li><code>[ZW + 120] &lt;- X0A</code></li>
<li><code>X0A &lt;- ZW</code></li>
<li><code>IP &lt;- [INTP + (p1 * 8)]</code></li>
</ul>
</li>
<li>an interrupt can be overwritten:
<ul>
<li>the interrupt-table is saved in the <code>INTP</code> register</li>
<li>to overwrite the interrupt <code>N</code>, write to <code>(INTP + (N * 8))</code> the absolute position of the address</li>
<li>example:
<ul>
<li><code>PUSH X00</code> |&gt; only needed when the value of <code>X00</code> should not be overwritten</li>
<li><code>MOV X00, IP</code> |&gt; this and the next command is not needed if the absolute position is already known</li>
<li><code>ADD/SUB X00, #RELATIVE-POS-FROM-GET-TO-INTERRUPT</code></li>
<li><code>MOV [INTP + #OVERWRITE_INT_NUM_MULTIPLIED_WITH_8], X00</code></li>
<li><code>POP X00</code> |&gt; only needed when the value of <code>X00</code> should not be overwritten</li>
</ul>
</li>
</ul>
</li>
<li>negative interrupts will always cause the illegal interrup to be called instead</li>
<li>when <code>INTCNT</code> is greather then the number of default interrupts and the called interrupt is not overwritten, the illegal interrupt will be called instead</li>
<li>default interrupts:
<ul>
<li><code>0</code>: illegal interrupt
<ul>
<li><code>X00</code> contains the number of the illegal interrupt</li>
<li>calls the exit interrupt with <code>(64 + illegal_interrup_number)</code></li>
<li>if the forbidden interrupt is the exit input, the program exits with <code>(64 + 4) = 68</code>, but does not calls the exit interrupt to do so</li>
<li>if this interrupt is tried to bee called, but it is forbidden to call this interrupt, the program exits with <code>63</code></li>
</ul>
</li>
<li><code>1</code>: unknown command
<ul>
<li><code>X00</code> contains the illegal command</li>
<li>calls the exit interrupt with <code>62</code></li>
</ul>
</li>
<li><code>2</code>: illegal memory
<ul>
<li>calls the exit interrupt with <code>61</code></li>
</ul>
</li>
<li><code>3</code>: arithmetic error
<ul>
<li>calls the exit interrupt with <code>60</code></li>
</ul>
</li>
<li><code>4</code>: exit
<ul>
<li>use <code>X00</code> to specify the exit number of the progress</li>
</ul>
</li>
<li><code>5</code>: allocate a memory-block
<ul>
<li><code>X00</code> saves the size of the block</li>
<li>if the value of <code>X00</code> is <code>-1</code> after the call the memory-block could not be allocated</li>
<li>if the value of <code>X00</code> is not <code>-1</code>, <code>X00</code> points to the first element of the allocated memory-block</li>
</ul>
</li>
<li><code>6</code>: reallocate a memory-block
<ul>
<li><code>X00</code> points to the memory-block</li>
<li><code>X01</code> saves the new size of the memory-block</li>
<li>if the value of <code>X01</code> is <code>-1</code> after the call the memory-block could not be reallocated, the old memory-block will remain valid and may be used and should be freed if it is not longer needed</li>
<li>if the value of <code>X01</code> is not <code>-1</code>, <code>X01</code> points to the first element of the allocated memory-block and the old memory-block was automatically freed, so it should not be used</li>
</ul>
</li>
<li><code>7</code>: free a memory-block
<ul>
<li><code>X00</code> points to the old memory-block</li>
<li>after this the memory-block should not be used</li>
</ul>
</li>
<li><code>8</code>: open new in stream
<ul>
<li><code>X00</code> contains a pointer to the STRING, which refers to the file which should be read</li>
<li>opens a new in stream to the specified file</li>
<li>is successfully the STREAM-ID will be saved in the <code>X00</code> register, if not <code>X00</code> will contain <code>-1</code></li>
<li>output operations are not supported on the new stream</li>
</ul>
</li>
<li><code>9</code>: open new out stream
<ul>
<li><code>X00</code> contains a pointer to the STRING, which refers to the file which should be created</li>
<li>opens a new out stream to the specified file</li>
<li>if the file exist already it's contend will be overwritten</li>
<li>is successfully the STREAM-ID will be saved in the <code>X00</code> register, if not <code>X00</code> will contain <code>-1</code></li>
<li>input operations are not supported on the new stream</li>
</ul>
</li>
<li><code>10</code>: open new out, append stream
<ul>
<li><code>X00</code> contains a pointer to the STRING, which refers to the file which should be created</li>
<li>opens a new out stream to the specified file</li>
<li>if the file exist already it's contend will be overwritten</li>
<li>is successfully the STREAM-ID will be saved in the <code>X00</code> register, if not <code>X00</code> will contain <code>-1</code></li>
</ul>
</li>
<li><code>11</code>: open new in/out stream
<ul>
<li><code>X00</code> contains a pointer to the STRING, which refers to the file which should be created</li>
<li>opens a new out stream to the specified file</li>
<li>if the file exist already it's contend will be overwritten</li>
<li>is successfully the STREAM-ID will be saved in the <code>X00</code> register, if not <code>X00</code> will contain <code>-1</code></li>
</ul>
</li>
<li><code>12</code>: open new in/out, append stream
<ul>
<li><code>X00</code> contains a pointer to the STRING, which refers to the file which should be created</li>
<li>opens a new out stream to the specified file</li>
<li>if the file exist already it's contend will be overwritten</li>
<li>is successfully the STREAM-ID will be saved in the <code>X00</code> register, if not <code>X00</code> will contain <code>-1</code></li>
</ul>
</li>
<li><code>13</code>: write
<ul>
<li><code>X00</code> contains the STREAM-ID</li>
<li><code>X01</code> contains the number of elements to write</li>
<li><code>X02</code> points to the elements to write</li>
<li>after execution <code>X01</code> will contain the number of written elements or <code>-1</code> if an error occurred</li>
</ul>
</li>
<li><code>14</code>: read
<ul>
<li><code>X00</code> contains the STREAM-ID</li>
<li><code>X01</code> contains the number of elements to read</li>
<li><code>X02</code> points to the elements to read</li>
<li>after execution <code>X01</code> will contain the number of elements, which has been read or <code>-1</code> if an error occurred.</li>
<li>if <code>X01</code> is <code>0</code> the end of the stream has reached</li>
<li>reading less bytes than expected does not mead that the stream has reached it's end</li>
</ul>
</li>
<li><code>15</code>: sync stream
<ul>
<li><code>X00</code> contains the STREAM-ID</li>
<li>if <code>X00</code> is set to <code>-1</code>, it will be tried to syncronize everything</li>
<li>if the synchronization was successfully <code>X00</code> will be set to <code>1</code>, if not <code>0</code></li>
</ul>
</li>
<li><code>16</code>: close stream
<ul>
<li><code>X00</code> contains the STREAM-ID</li>
<li>if the stream was closed successfully <code>X00</code> will contain <code>1</code>, if not <code>0</code></li>
</ul>
</li>
<li><code>17</code>: get stream pos
<ul>
<li><code>X00</code> contains the STREAM-ID</li>
<li><code>X01</code> will contain the position of the stream or <code>-1</code> if something went wrong.</li>
</ul>
</li>
<li><code>18</code>: set stream pos
<ul>
<li><code>X00</code> contains the STREAM-ID</li>
<li><code>X01</code> contains the position to be set.</li>
<li>if the stream-ID is the ID of a default stream the behavior is undefined.</li>
<li><code>X01</code> will contain the new stream position.</li>
</ul>
</li>
<li><code>19</code>: set stream to end
<ul>
<li><code>X00</code> contains the STREAM-ID</li>
<li>this will set the stream position to the end</li>
<li><code>X01</code> will the new file pos or <code>-1</code> if something went wrong</li>
</ul>
</li>
<li><code>20</code>: remove file
<ul>
<li><code>X00</code> contains a pointer of a STRING with the file</li>
<li>if the file was successfully removed <code>X00</code> will contain <code>1</code>, if not <code>0</code></li>
</ul>
</li>
<li><code>21</code>: make dictionary
<ul>
<li><code>X00</code> contains a pointer of a STRING with the dictionary</li>
<li>if the dictionary was successfully created <code>X00</code> will contain <code>1</code>, if not <code>0</code></li>
</ul>
</li>
<li><code>22</code>: remove dictionary
<ul>
<li><code>X00</code> contains a pointer of a STRING with the dictionary</li>
<li>if the dictionary was successfully removed <code>X00</code> will contain <code>1</code>, if not <code>0</code></li>
<li>if the dictionary is not empty this call will fail (and set <code>X00</code> to <code>0</code>)</li>
</ul>
</li>
<li><code>23</code>: to get the time in milliseconds
<ul>
<li><code>X00</code> will contain the time in milliseconds or <code>-1</code> if not available</li>
</ul>
</li>
<li><code>24</code>: to wait the given time in nanoseconds
<ul>
<li><code>X00</code> contain the number of nanoseconds to wait (only values from <code>0</code> to <code>999999999</code> are allowed)</li>
<li><code>X01</code> contain the number of seconds to wait</li>
<li><code>X00</code> and <code>X01</code> will contain the remaining time (<code>0</code> if it finished waiting)</li>
<li><code>X02</code> will be <code>1</code> if the call was successfully and <code>0</code> if something went wrong
<ul>
<li>if <code>X02</code> is <code>1</code> the remaining time will always be <code>0</code></li>
<li>if <code>X02</code> is <code>0</code> the remaining time will be greater <code>0</code></li>
</ul>
</li>
<li><code>X00</code> will not be negative if the progress waited too long</li>
</ul>
</li>
<li><code>25</code>: socket client create
<ul>
<li>makes a new client socket</li>
<li><code>X00</code> will be set to the SOCKET-ID or <code>-1</code> if the operation failed</li>
</ul>
</li>
<li><code>26</code>: socket client connect
<ul>
<li><code>X00</code> points to the SOCKET-ID</li>
<li><code>X01</code> points to a STRING, which names the host</li>
<li><code>X02</code> contains the port
<ul>
<li>the port will be the normal number with the normal byte order</li>
</ul>
</li>
<li>connects an client socket to the host on the port</li>
<li><code>X01</code> will be set to the <code>1</code> on success and <code>0</code> on a fail</li>
<li>on success, the SOCKET-ID, can be used as a STREAM-ID</li>
</ul>
</li>
<li><code>27</code>: socket server create
<ul>
<li><code>X00</code> contains the port
<ul>
<li>the port will be the normal number with the normal byte order</li>
</ul>
</li>
<li>makes a new server socket</li>
<li><code>X00</code> will be set to the SOCKET-ID or <code>-1</code> when the operation fails</li>
</ul>
</li>
<li><code>28</code>: socket server listens
<ul>
<li><code>X00</code> contains the SOCKET-ID</li>
<li><code>X01</code> contains the MAX_QUEUE length</li>
<li>let a server socket listen</li>
<li><code>X01</code> will be set to <code>1</code> or <code>0</code> when the operation fails</li>
</ul>
</li>
<li><code>29</code>: socket server accept
<ul>
<li><code>X00</code> contains the SOCKET-ID</li>
<li>let a server socket accept a client</li>
<li>this operation will block, until a client connects</li>
<li><code>X01</code> will be set a new SOCKET-ID, which can be used as STREAM-ID, or <code>-1</code></li>
</ul>
</li>
<li><code>30</code>: random
<ul>
<li><code>X00</code> will be filled with random bits</li>
</ul>
</li>
<li><code>31</code>: memory copy
<ul>
<li>copies a block of memory</li>
<li>this function has undefined behavior if the two blocks overlap</li>
<li><code>X00</code> points to the target memory block</li>
<li><code>X01</code> points to the source memory block</li>
<li><code>X02</code> has the length of bytes to bee copied</li>
</ul>
</li>
<li><code>32</code>: memory move
<ul>
<li>copies a block of memory</li>
<li>this function makes sure, that the original values of the source block are copied to the target block (even if the two block overlap)</li>
<li><code>X00</code> points to the target memory block</li>
<li><code>X01</code> points to the source memory block</li>
<li><code>X02</code> has the length of bytes to bee copied</li>
</ul>
</li>
<li><code>33</code>: memory byte set
<ul>
<li>sets a memory block to the given byte-value</li>
<li><code>X00</code> points to the block</li>
<li><code>X01</code> the first byte contains the value to be written to each byte</li>
<li><code>X02</code> contains the length in bytes</li>
</ul>
</li>
<li><code>34</code>: memory set
<ul>
<li>sets a memory block to the given int64-value</li>
<li><code>X00</code> points to the block</li>
<li><code>X01</code> contains the value to be written to each element</li>
<li><code>X02</code> contains the count of elements to be set</li>
</ul>
</li>
<li><code>35</code>: string length
<ul>
<li><code>X00</code> points to the STRING</li>
<li><code>X00</code> will be set to the length of the string/ the (byte-)offset of the <code>'\0'</code> character</li>
</ul>
</li>
<li><code>36</code>: string to number
<ul>
<li><code>X00</code> points to the STRING</li>
<li><code>X01</code> points to the base of the number system
<ul>
<li>(for example <code>10</code> for the decimal system or <code>2</code> for the binary system)</li>
</ul>
</li>
<li><code>X00</code> will be set to the converted number</li>
<li><code>X01</code> will point to the end of the number-STRING
<ul>
<li>this might be the <code>\0'</code> terminating character</li>
</ul>
</li>
<li>if the STRING contains illegal characters or the base is not valid, the behavior is undefined</li>
<li>this function will ignore leading space characters</li>
</ul>
</li>
<li><code>37</code>: string to floating point number
<ul>
<li><code>X00</code> points to the STRING</li>
<li><code>X00</code> will be set to the converted number</li>
<li><code>X01</code> will point to the end of the number-STRING
<ul>
<li>this might be the <code>\0'</code> terminating character</li>
</ul>
</li>
<li>if the STRING contains illegal characters or the base is not valid, the behavior is undefined</li>
<li>this function will ignore leading space characters</li>
</ul>
</li>
<li><code>38</code>: number to string
<ul>
<li><code>X00</code> is set to the number to convert</li>
<li><code>X01</code> is points to the buffer to be filled with the number in a STRING format</li>
<li><code>X02</code> contains the base of the number system
<ul>
<li>the minimum base is <code>2</code></li>
<li>the maximum base is <code>36</code></li>
<li>other values lead to undefined behavior</li>
</ul>
</li>
<li><code>X00</code> will be set to the length of the STRING</li>
</ul>
</li>
<li><code>39</code>: floating point number to string
<ul>
<li><code>X00</code> is set to the number to convert</li>
<li><code>X02</code> contains the maximum amount of digits to be used to represent the floating point number</li>
<li><code>X01</code> is points to the buffer to be filled with the number in a STRING format</li>
</ul>
</li>
<li><code>40</code>: format string
<ul>
<li><code>X00</code> is set to the STRING input</li>
<li><code>X01</code> contains the buffer for the STRING output
<ul>
<li>if <code>X01</code> is set to <code>-1</code>, <code>X01</code> will be allocated to a memory block
<ul>
<li>the allocated memory block will be exact large enough to contain the formatted STRING</li>
<li>if there could not be allocated enough memory, <code>X01</code> will be set to <code>-1</code></li>
</ul>
</li>
</ul>
</li>
<li><code>X00</code> will be set to the length of the output string</li>
<li>the register <code>X02..XNN</code> are for the formatting parameters
<ul>
<li>if there are mor parameters used then there are registers the behavior is undefined.
<ul>
<li>that leads to a maximum of 249 parameters.</li>
</ul>
</li>
</ul>
</li>
<li>formatting:
<ul>
<li>everything, which can not be formatted, will be delegated to the target buffer</li>
<li><code>%s</code>: the next argument points to a STRING, which should be inserted here</li>
<li><code>%c</code>: the next argument points to a character, which should be inserted here
<ul>
<li>note that characters may contain more than one byte
<ul>
<li><code>BIN-0.......</code> -&gt; one byte (equivalent to an ASCII character)</li>
<li><code>BIN-10......</code> -&gt; invalid, treated as one byte</li>
<li><code>BIN-110.....</code> -&gt; two bytes</li>
<li><code>BIN-1110....</code> -&gt; three bytes</li>
<li><code>BIN-11110...</code> -&gt; four bytes</li>
<li><code>BIN-111110..</code> -&gt; invalid, treated as five byte</li>
<li><code>BIN-1111110.</code> -&gt; invalid, treated as six byte</li>
<li><code>BIN-11111110</code> -&gt; invalid, treated as seven byte</li>
<li><code>BIN-11111111</code> -&gt; invalid, treated as eight byte</li>
</ul>
</li>
</ul>
</li>
<li><code>%B</code>: the next argument points to a byte, which should be inserted here (without being converted to a STRING)</li>
<li><code>%d</code>: the next argument contains a number, which should be converted to a STRING using the decimal number system and than be inserted here</li>
<li><code>%f</code>: the next argument contains a floating point number, which should be converted to a STRING and than be inserted here</li>
<li><code>%p</code>: the next argument contains a pointer, which should be converted to a STRING
<ul>
<li>if not the pointer will be converted by placing a <code>&quot;p-&quot;</code> and then the pointer-number converted to a STRING using the hexadecimal number system</li>
<li>if the pointer is <code>-1</code> it will be converted to the STRING <code>&quot;---&quot;</code></li>
</ul>
</li>
<li><code>%h</code>: the next argument contains a number, which should be converted to a STRING using the hexadecimal number system and than be inserted here</li>
<li><code>%b</code>: the next argument contains a number, which should be converted to a STRING using the binary number system and than be inserted here</li>
<li><code>%o</code>: the next argument contains a number, which should be converted to a STRING using the octal number system and than be inserted here</li>
</ul>
</li>
</ul>
</li>
<li><code>41</code>: load file
<ul>
<li><code>X00</code> is set to the path (inclusive name) of the file</li>
<li><code>X00</code> will point to the memory block, in which the file has been loaded</li>
<li><code>X01</code> will be set to the length of the file (and the memory block)</li>
<li>when an error occured <code>X00</code> will be set to <code>-1</code></li>
</ul>
</li>
</ul>
</li>
<li>binary:
<ul>
<li><code>23 &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>PUSH &lt;PARAM&gt;</code></p>
<ul>
<li>pushes the parameter to the stack</li>
<li>definition:
<ul>
<li><code>[SP] &lt;- p1</code></li>
<li><code>SP &lt;- SP + 8</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>24 &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>POP &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>pops the highest value from the stack to the parameter</li>
<li>definition:
<ul>
<li><code>SP &lt;- SP - 8</code></li>
<li><code>p1 &lt;- [SP]</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>25 &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>INC &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>increments the param by one</li>
<li>definition:
<ul>
<li><code>if p1 = MAX_VALUE</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 = -1</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 + 1</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>0F &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>DEC &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>decrements the param by one</li>
<li>definition:
<ul>
<li><code>if p1 = MIN_VALUE</code>
<ul>
<li><code>CARRY &lt;- 1</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 = 1</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>CARRY &lt;- 0</code></li>
<li><code>ZREO &lt;- 0</code></li>
</ul>
</li>
<li><code>p1 &lt;- p1 - 1</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>0E &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>FPTN &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>converts the value of the floating point param to a number</li>
<li>the value after the</li>
<li>definition:
<ul>
<li><code>p1 &lt;- as_num(p1)</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>37 &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>NTFP &lt;NO_CONST_PARAM&gt;</code></p>
<ul>
<li>converts the value of the number param to a floating point</li>
<li>the value after the</li>
<li>definition:
<ul>
<li><code>p1 &lt;- as_fp(p1)</code></li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>36 &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<p><code>CHKFP &lt;PARAM&gt;</code></p>
<ul>
<li>checks weater the floating point param is a positive and negative infinity and for NaN</li>
<li>definition:
<ul>
<li><code>if p1 is positive-infinity</code>
<ul>
<li><code>GREATHER &lt;- 1</code></li>
<li><code>LOWER &lt;- 0</code></li>
<li><code>NAN &lt;- 0</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 is negative-infinity</code>
<ul>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>LOWER &lt;- 1</code></li>
<li><code>NAN &lt;- 0</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>else if p1 is NaN</code>
<ul>
<li><code>LOWER &lt;- 0</code></li>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>NAN &lt;- 1</code></li>
<li><code>ZERO &lt;- 0</code></li>
</ul>
</li>
<li><code>else</code>
<ul>
<li><code>LOWER &lt;- 0</code></li>
<li><code>GREATHER &lt;- 0</code></li>
<li><code>NAN &lt;- 0</code></li>
<li><code>ZERO &lt;- 1</code></li>
</ul>
</li>
<li><code>IP &lt;- IP + CMD_LEN</code></li>
</ul>
</li>
<li>binary:
<ul>
<li><code>38 &lt;B-P1.TYPE&gt; 00 00 00 00 &lt;B-P1.OFF_REG|00&gt; &lt;B-P1.NUM_REG|B-P1.OFF_REG|00&gt;</code></li>
<li><code>[P1.NUM_NUM]</code></li>
<li><code>[P1.OFF_NUM]</code></li>
</ul>
</li>
</ul>
<h2 id="not-yet-theresupported">not (yet) there/supported</h2>
<ul>
<li>execute other programs</li>
<li>Multi-threading/-progressing</li>
</ul>

    </body>
</html>
            
